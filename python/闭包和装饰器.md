## 1. 闭包
在函数内部再定义一个函数，并且内部函数用到了外部函数作用域的变量，那么将这个内部函数以及用到的外部函数内的变量一起称为**闭包**。
举例：
```python
In [1]: def line(a, b):
   ...:     def get_y_axis(x):
   ...:         return a * x + b  # 内部函数使用了外部函数的变量a和b
   ...:     return get_y_axis     # 返回值是闭包函数名，注意不是函数调用没有小括号
   ...: 
   ...: 

In [2]: L1 = line(1, 1)  # 创建一条直线： y=x+1
```
注意： 闭包中不要引用外部函数中任何循环变量或后续会发生变化的变量

## 2. 装饰器
装饰器（decorator）接受一个callable对象（可以是函数或者实现了__call__方法的类）作为参数，并返回一个callable对象

### 2.1 被装饰的函数无参数
没使用装饰器之前：
```python
def f1():
    print('function f1...')

def f2():
    print('function f1...')

f1()  # 输出function f1...
f2()  # 输出function f2...
```
创建装饰器，接受函数参数，返回一个闭包函数inner:
```python
def login_required(func):
    def inner():  # inner是一个闭包，它使用了外部函数的变量func，即传入的原函数引用f1、f2...
        if func.__name__ == 'f1':  # 这里是权限验证的逻辑判断，此处简化为只能调用f1
            print(func.__name__, ' 权限验证成功')
            func()  # 执行原函数，相当于f1()或f2()...
        else:
            print(func.__name__, ' 权限验证失败')
    return inner
```

使用装饰器：
```python
def f1():
    print('function f1...')

def f2():
    print('function f2...')

new_f1 = login_required(f1)  # 将f1传入装饰器，返回inner引用，并赋值给新的变量new_f1
new_f1()  # 执行函数，即执行inner()，这个闭包中使用的func变量指向原f1函数体

new_f2 = login_required(f2)  # 将f2传入装饰器，返回inner引用，并赋值给新的变量new_f2
new_f2()  # 执行函数，即执行inner()，func变量指向原f2，所以它不会通过权限验证，即不会执行func()

# 输出结果：
f1  权限验证成功
function f1...
f2  权限验证失败
```
上面使用装饰器有个问题，就是用户原来是调用f1()、f2()... ，现在你让他们调用new_f1()、new_f2()... ， 这样肯定不行，所以需要修改如下：
```python
f1 = login_required(f1)  # 将f1引用传入装饰器，此时func指向了原f1函数体。返回inner引用，并赋值给f1，即现在是func指向原函数体，而f1重新指向了返回的inner闭包
f1()  # 执行函数，即执行inner()，这个闭包中使用的func变量指向原f1函数体
```
上述两个步骤可以用 Python 的语法糖 @ 简写为：
```python
# 1. 定义时
@login_required
def f1():
    print('function f1...')

# 2. 调用时
f1()
```
### 2.2 被装饰的函数有参数
```python
def login_required(func):
    def inner(a):
        if func.__name__ == 'f1':
            print(func.__name__, ' 权限验证成功')
            func(a)
        else:
            print(func.__name__, ' 权限验证失败')
    return inner

@login_required
def f1(a):
    print('function f1, args: a=', a)

f1(10)

# 输出结果：
f1  权限验证成功
function f1, args: a= 10
```

现在的装饰器可以正确装饰f1(a)函数，但是假如有一个f2(a, b, c)有三个参数呢，肯定报错，所以还要修改装饰器，使用Python中的*args和**kwargs来匹配任意长度的位置参数或关键字参数：
```python
def login_required(func):
    def inner(*args, **kwargs):
        if func.__name__ == 'f1':
            print(func.__name__, ' 权限验证成功')
            func(*args, **kwargs)
        else:
            print(func.__name__, ' 权限验证失败')
    return inner
```

### 2.3 被装饰的函数有返回值
```python
def login_required(func):
    def inner(*args, **kwargs):
        if func.__name__ == 'f1':
            print(func.__name__, ' 权限验证成功')
            return func(*args, **kwargs)
        else:
            print(func.__name__, ' 权限验证失败')
    return inner

@login_required
def f1(a, b, c):
    print('function f1, args: a={}, b={}, c={}'.format(a, b, c))
    return 'hello, world'

res = f1(10, 20, 30)
print(res)

# 输出结果：
f1  权限验证成功
function f1, args: a=10, b=20, c=30
hello, world
```
### 2.4 装饰器带参数
像Flask的@route('/index')就是带参数的，其实route只是一个函数，它返回真正的装饰器，即在原来的装饰器外面再加一层函数：
```python
def logging(level):
    def decorator(func):
        def wrapper(*args, **kwargs):
            print('[日志级别 {}]: 被装饰的函数名是 {}'.format(level, func.__name__))
            return func(*args, **kwargs)
        return wrapper
    return decorator


@logging('DEBUG')  # 等价于 f1 = logging('DEBUG')(f1) ，即先执行loggin('DEBUG')，返回decorator引用（真正的装饰器），再用decorator装饰f1，返回wrapper
def f1(a, b, c):
    print('function f1, args: a={}, b={}, c={}'.format(a, b, c))
    return 'hello, world'


@logging('INFO')
def f2():
    print('function f2...')


res = f1(10, 20, 30)
print(res)
f2()

# 输出结果：
[日志级别 DEBUG]: 被装饰的函数名是 f1
function f1, args: a=10, b=20, c=30
hello, world
[日志级别 INFO]: 被装饰的函数名是 f2
function f2...
```
### 2.5 使用@wraps