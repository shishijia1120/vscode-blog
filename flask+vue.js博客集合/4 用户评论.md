# 用户评论

>用户在浏览你的博客文章后，可能会在底下评论，增加互动性。一篇文章允许有多条评论，一个用户可以在多篇文章下面发表评论，所以都是一对多关系。同时，评论支持多级回复，支持点赞功能。
-----
### 1.数据库
#### 1.1 声明模型
Post与Comment是一对多关系，同时User与Comment也是一对多关系。登录的用户除了可以在文章下面发表评论以外，还可以回复别人的评论，所以评论模型是自引用的一对多关系，同时支持级联删除。

修改model.py增加Comment数据模型：
```python
class User(PaginatedAPIMixin,db.Model):
    ...
    comments=db.relationship('Comment',backref='author',lazy='dynamic',cascade='all,delete-orphan')

class Post(PaginatedAPIMixin,db.Model):
...
    comments=db.relationship('Comment',backref='post',lazy='dynamic',cascade='all,delete-orphan')

class Comment(PaginatedAPIMixin,db.Model):
    __tablename__='comments'
    id=db.Column(db.Integer,primary_key=True)
    body=db.Column(db.Text)
    timestamp=db.Column(db.DateTime,index=True,default=datetime.utcnow)
    mark_read=db.Column(db.Boolean,default=False) # 文章作者会收到评论提醒，可以标为已读
    disabled=db.Column(db.Boolean,default=False) # 屏蔽显示评论
    # 外键，评论作者的id
    author_id=db.Column(db.Integer,db.ForeignKey('users.id'))
    # 外键，评论所属文章的id
    post_id=db.Column(db.Integer,db.ForeignKey('posts.id'))
    # 自引用的多级评论实现
    parent_id=db.Column(db.Integer,db.ForeignKey('comments.id'))
    # 级联删除的cascade必须定义在“多”的那一侧，所以不能这样定义：parent=db.relationship('Comment',backref='children',remote_side=[id], cascade='all, delete-orphan')
    parent=db.relationship('Comment',backref=db.backref('children',cascade='all, delete-orphan'), remote_side=[id])
    def __repr__(self):
            return '<Comment {}>'.format(self.id)

    def get_descendants(self):
            '''获取一级评论的所有子孙'''
            data = set()

            def descendants(comment):
                if comment.children:
                    data.update(comment.children)
                    for child in comment.children:
                        descendants(child)
            descendants(self)
            return data

```
### 2.RESTful API设计
|HTTP方法|资源URL|说明|
|----|----|----|
|POST|/comments/|在某篇博客文章下面发表新评论|
|GET|/comments/|返回评论集合，分页|
|GET|/posts/<int:id>/comments/|返回当前文章下面的一级评论|
|GET|/comments/<int:id>|返回单个评论|
|PUT|/comments/<int:id>|修改单个评论|
|DELETE|/comments/<int:id>|删除单个评论|
|GET|/comments/<int:id>/like|点赞评论|
|GET|/comments/<int:id>/unlike|取消点赞评论|


#### 2.3发表评论
在某篇博客文章下面发表新评论：
```python
def create_comment():
    '''在某篇博客文章下面发表新评论'''
    data=request.get_json()
    if not data:
        return bad_request('You must post JSON data.')
    if 'body' not in data or not data.get('body').strip():
        return bad_request('Body is required.')
    if 'post_id' not in data or not data.get('post_id'):
        return bad_request('Post id is required.')
    
    post=Post.query.get_or_404(int(data.get('post_id')))
    comment=Comment()
    comment.from_dict(data)
    comment.author=g.current_user
    comment.post=post
    db.session.add(comment)
    response=jsonify(comment.to_dict())
    response.status_code=201
    response.headers['Location']=url_for('api.get_comment',id=comment.id)
    return response

```
#### 2.4返回评论集合，分页
```python
def get_comments():
    page=request.args.get('page',1,type=int)
    per_page=min(
        request.args.get(
            'per_page',current_app.config['COMMENTS_PER_PAGE'], type=int), 100))
    data=Comment.to_collection_dict(
        Comment.query.order_by(Comment.timestamp.desc()),page,per_page,'api.get_comments'
    )
    return jsonify(data)
    )
``` 

### 3.用户评论CURD前台
-----
预设实现功能：
- 多级评论展示:
   一级评论和子孙级评论（难点：子孙评论要缩进）
- 发表评论：
- 回复评论：点击回复评论，立即在父级评论下方出现输入框
- 屏蔽、删除、恢复评论






#### 3.1多级评论展示
后端需要增加一个API，只返回该文章下面的顶层评论，每个顶层评论下面如果有子孙评论，则附加到descendants属性上，这是为了前端展示多级评论时，只显示两层，免得缩进太多就不好看了。

PostDetail2.vue:
```javascript
 getPostComments (id) {
      let page = 1
      let per_page = 10
      if (typeof this.$route.query.page != 'undefined') {
        page = this.$route.query.page
      }

      if (typeof this.$route.query.per_page != 'undefined') {
        per_page = this.$route.query.per_page
      }
      
      const path = `/api/posts/${id}/comments/?page=${page}&per_page=${per_page}`
      this.$axios.get(path)
        .then((response) => {
          // handle success
          this.comments = response.data
          //if (response.data._meta.total_items > 0) {
          //  this.comments = response.data
          //}
        })
        .catch((error) => {
          // handle error
          console.error(error)
        })
    },
created () {
    const post_id = this.$route.params.id
    this.getPost(post_id)
    this.getPostComments(post_id)
}
```




修改posts.py:
```python
@bp.route('/posts/<int:id>/comments/', methods=['GET'])
def get_post_comments(id):
    '''返回当前文章下面的一级评论'''
    post = Post.query.get_or_404(id)
    page = request.args.get('page', 1, type=int)
    per_page = min(
        request.args.get(
            'per_page', current_app.config['COMMENTS_PER_PAGE'], type=int), 100)
    # 先获取一级评论
    data = Comment.to_collection_dict(
        post.comments.filter(Comment.parent==None).order_by(Comment.timestamp.desc()), page, per_page,
        'api.get_post_comments', id=id)
    # 再添加子孙到一级评论的 descendants 属性上
    for item in data['items']:
        comment = Comment.query.get(item['id'])
        descendants = [child.to_dict() for child in comment.get_descendants()]
        # 按 timestamp 排序一个字典列表
        from operator import itemgetter
        item['descendants'] = sorted(descendants, key=itemgetter('timestamp'))
    return jsonify(data)
```






#### 3.2回复评论
在PostDetail.vue组件创建时：
```javascript
export default{
    ...
    methods:{
        onClickReply(comment){
            //用户需要先登录
            if(!this.sharedState.is_authenticated){
                this.$toasted.error('您需要登录才能回复评论...'，{icon: 'fingerprint'})
            }
                this.$router.replace({
                    path: '/login',
                    query: { redirect: this.$route.path + '#c' + comment.id }
        })
              this.commentForm.parent_id=comment.id
                this.commentForm.author_id=comment.author.id
                this.commentForm.author_name=comment.athor.name||commentForm.author.username
                },
                onSubmitAddComment(e){
                    this.commentForm.errors=0
                    if(!this.commentForm.body){
                        this.commentForm.errors++
                        this.commentForm.bodyError='Body is required.'
                    else{
                        this.commentForm.bodyError=null
                    }
                    if(this.commentForm.errors>0){
                        return false
                    }
                    
                    const path='/api/comments'
                    let payload=''
                    if(this.commentForm.parent_id){
                        //说明是回复评论
                        const at_who=
                        payload={
                            body:at_who+this.commentForm.body,
                            post_id:this.$route.params.id,
                            parent_id:this.commentForm.parent_id
                        }
                    }else{
                        //说明是发表一级评论
                        payload={
                            body:this.commentForm.body,
                            post_id:this.$route.params.id
                        }
                    }

                    this.$axios.post(path,payload)
                        .then((response)=>{
                            //handle success
                            this.getPostComments(this.$route.params.id)
                            this.$toasted.success('Successed add a new comment', { icon: 'fingerprint' })
                            this.onResetAddComment()
                            .catch((error)=>{
                                //handle error
                                console.log(error.response.data)
                                this.$toasted.error(error.response.data.message, { icon: 'fingerprint' })
        })
                            })
                        })



                    }
                }





    }
}
```
#### 3.3 删除/屏蔽评论
文章作者可以删除或屏蔽该文章下面的任何评论，而评论的的作者只能删除自己发的评论。
注意：删除评论也会删除该评论下面所有子孙评论，级联删除。

#### 3.4 点赞
一条评论可以被多个用户点赞，一个用户也可以点赞多个不同的评论，所以它们是多对多关系。
```python
# 评论点赞
comments_likes = db.Table(
    'comments_likes',
    db.Column('user_id', db.Integer, db.ForeignKey('users.id')),
    db.Column('comment_id', db.Integer, db.ForeignKey('comments.id')),
    db.Column('timestamp', db.DateTime, default=datetime.utcnow)
)

class Comment(PaginatedAPIMixin, db.Model):
    ...
     # 评论与对它点赞的人是多对多关系
    likers = db.relationship('User', secondary=comments_likes, backref=db.backref('liked_comments', lazy='dynamic'))
    ...

    def is_liked_by(self,user):
        '''判断用户 user 是否已经对该评论点过赞'''
        return user in self.likers
    
    def liked_by(self,user):
        '''点赞'''
        if not self.is_liked_by(user):
            self.likers.append(user)

     def unliked_by(self, user):
        '''取消点赞'''
        if self.is_liked_by(user):
            self.likers.remove(user)
```
修改comments.py,增加两个API：
```python
@bp.route('/comments/<int:id>/like', methods=['GET'])
@token_auth.login_required
def like_comment(id):
    '''点赞评论'''
    comment = Comment.query.get_or_404(id)
    comment.liked_by(g.current_user)
    db.session.add(comment)
    db.session.commit()
    return jsonify({
        'status': 'success',
        'message': 'You are now liking comment [ id: %d ].' % id
    })


@bp.route('/comments/<int:id>/unlike', methods=['GET'])
@token_auth.login_required
def unlike_comment(id):
    '''取消点赞评论'''
    comment = Comment.query.get_or_404(id)
    comment.unliked_by(g.current_user)
    db.session.add(comment)
    db.session.commit()
    return jsonify({
        'status': 'success',
        'message': 'You are not liking comment [ id: %d ] anymore.' % id
    })
```
