# 用户通知
> 实现动态通知已登录的用户，你的文章有新的评论了、你有新的粉丝了、你的评论被人点赞了、你关注的大神又发布新文章了，新的内容会在头像左上角打上红色小标记，以提醒用户；通知功能是非常重要和实用的。设置的时间轮询间隔为10秒。
> ## 1. 用户收到的评论
> ### 1.1 增加API
> 用户发布文章后，陆续有其他用户在下面评论了，此时，文章作者需要知道他的哪篇文章有新评论了。
models.py:
```python
class User(PaginatedAPIMixin, db.Model):
    ...
    # 用户最后一次查看 收到的评论 页面的时间，用户判断哪些收到的评论是新的
    last_recived_comments_read_time=db.Column(db.DateTime)
```
修改users.py:
```python

def get_user_recived_comments(id):
    '''返回该用户收到的所有评论'''
    user=User.query.get_or_404(id)
    if g.current_user != user:
        return error_response(403)
     page = request.args.get('page', 1, type=int)
    per_page = min(
        request.args.get(
            'per_page', current_app.config['COMMENTS_PER_PAGE'], type=int), 100)
    # 用户发布的所有文章ID
```
## 2. 动态通知
增加一个Notification数据模型，它用来存储每个用户的每一类通知。
models.py:
```python
class User(PaginatedAPIMixin, db.Model):
    ...
    # 用户的通知
    notifications = db.relationship('Notification', backref='user',
                                    lazy='dynamic', cascade='all, delete-orphan')


class Notification(db.Model):  # 不需要分页
    __tablename__ = 'notifications'
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(128), index=True)
    user_id = db.Column(db.Integer, db.ForeignKey('users.id'))
    timestamp = db.Column(db.Float, index=True, default=time)
    payload_json = db.Column(db.Text)

    def __repr__(self):
        return '<Notification {}>'.format(self.id)

    def get_data(self):
        return json.loads(str(self.payload_json))

    def to_dict(self):
        data = {
            'id': self.id,
            'name': self.name,
            'user': {
                'id': self.user.id,
                'username': self.user.username,
                'name': self.user.name,
                'avatar': self.user.avatar(128)
            },
            'timestamp': self.timestamp,
            'payload': self.get_data(),
            '_links': {
                'self': url_for('api.get_notification', id=self.id),
                'user_url': url_for('api.get_user', id=self.user_id)
            }
        }
        return data

    def from_dict(self, data):
        for field in ['body', 'timestamp']:
            if field in data:
                setattr(self, field, data[field])
```

创建notifications.py:
```python
from flask import jsonify, g
from app.api import bp
from app.api.auth import token_auth
from app.api.errors import error_response
from app.models import Notification


@bp.route('/notifications/<int:id>', methods=['GET'])
@token_auth.login_required
def get_notification(id):
    '''返回一个用户通知'''
    notification = Notification.query.get_or_404(id)
    if g.current_user != notification.user:
        return error_response(403)
    data = notification.to_dict()
    return jsonify(data)
```
修改__init__.py，引入notifications.py:
```python
from flask import Blueprint

bp = Blueprint('api', __name__)

# 写在最后是为了防止循环导入，ping.py文件也会导入 bp
from app.api import ping, tokens, errors, users, posts, comments, notifications
```



### 2.1 新评论通知
修改models.py:
```python

class User(PaginatedAPIMixin, db.Model):
 ...
    def new_recived_comments(self):
        '''用户发布的文章下面收到的新评论计数'''
        last_read_time = self.last_recived_comments_read_time or datetime(1900, 1, 1)
        # 用户发布的所有文章
        user_posts_ids = [post.id for post in self.posts.all()]
        # 用户收到的所有评论，即评论的 post_id 在 user_posts_ids 集合中，且评论的 author 不是当前用户（即文章的作者）
        recived_comments = Comment.query.filter(Comment.post_id.in_(user_posts_ids), Comment.author != self).order_by(Comment.mark_read, Comment.timestamp.desc())
        # 新评论
        return recived_comments.filter(Comment.timestamp > last_read_time).count()


    def add_notification(self,name,data):
        '''给用户示例对象增加通知'''
        # 如果具有相同名称的通知已存在，则先删除该通知
        self.notifications.filter_by
        self.notifications

        # 为用户添加通知，写入数据库
        n=Notification(name,payload_json=json.dumps(data),user=self)
        db.session.add(n)
        return n
```

每当有用户发表评论时，都要给该文章作者增加新评论通知，通知的名字为unread_recived_comments_count，通知的payload只需要存储新评论的最新计数即可

修改comments.py中的create_comment()和delete_comment():
```python
def create_comment():
    ...
    # 给文章作者发送新评论通知
    post.author.add_notification('unread_recived_comments_count',
     post.author.new_recived_comments())

    ...
def delete_comment(id):
...
# 给文章作者发送新评论通知（需要自动减1）
    comment.post.author.add_notification('unread_recived_comments_count',
                                         comment.post.author.new_recived_comments())
...
```
当文章作者访问 http://localhost:8080/notifications/comments 页面时，还需要根据分页的情况，动态修改 unread_recived_comments_count 通知的新评论计数

修改 back-end/app/api/users.py ：
```python
@bp.route('/users/<int:id>/recived-comments/', methods=['GET'])
@token_auth.login_required
def get_user_recived_comments(id):
    '''返回该用户收到的所有评论'''
    user=User.query.get_or_404(id)
    if g.current_user!=user:
        return error_response(403)
    page = request.args.get('page', 1, type=int)
    per_page = min(
        request.args.get(
            'per_page', current_app.config['COMMENTS_PER_PAGE'], type=int), 100)
    # 用户发布的所有文章ID集合
    user_posts_ids=[post.id for post in g.current_user.posts.all()]
    # 获取该用户所有文章下的评论（不包括自己的）
    data=Comment.to_collection_dict(
        Comment.query.filter(Comment.post_id in user_posts_ids,Comment.author!= g.current_user)
        .order_by(Comment.mark_read,Comment.timestamp.desc()),
         page, per_page, 'api.get_user_recived_comments', id=id)
    
    # 标记哪些评论是新的
    last_read_time=user.last_recived_comments_read_time or datetime(1900, 1, 1)

    for item in data['items']:
        if item['timestamp'] > last_read_time:
            item['is_new']=True
    # 需要考虑分页的问题，比如新评论有25条，默认分页是每页10条，
    # 如果用户请求第一页时就更新 last_recived_comments_read_time，那么后15条就被认为不是新评论了，这是不对的
    if data['_meta']['page'] * data['_meta']['per_page'] >= user.new_recived_comments():
        # 更新 last_recived_comments_read_time 属性值
        user.last_recived_comments_read_time = datetime.utcnow()
        # 将新评论通知的计数归零
        user.add_notification('unread_recived_comments_count', 0)
    else:
        # 用户剩余未查看的新评论数
        n = user.new_recived_comments() - data['_meta']['page'] * data['_meta']['per_page']
        # 将新评论通知的计数更新为未读数
        user.add_notification('unread_recived_comments_count', n)
    db.session.commit()
    return jsonify(data)
    
```


### 2.2 获取用户的新通知
修改users.py:
```python
@bp.route('/users/<int:id>/notifications/', methods=['GET'])
@token_auth.login_required
def get_user_notifications(id):
    '''返回该用户的新通知'''
    user=User.query.get_or_404(id)
    if g.current_user!=user:
        return error_response(403)
    # 只返回上次看到的通知以来发生的新通知
     # 比如用户在 10:00:00 请求一次该API，在 10:00:10 再次请求该API只会返回 10:00:00 之后产生的新通知

    notifications=user.notifications.filter(
        Notification.timestamp > since).order_by(Notification.timestamp.asc())
    return jsonify([n.to_dict() for n in notifications ])
```

### 2.3 动态徽章提醒
前端 Navbar.vue 组件每隔 10 秒请求一次 /api/users/<ini:id>/notifications/ 获取当前登录用户的新通知：
```javascript
<script>
import store from '../../store'
// 在 JQuery 中使用 axios 的话需要重新导入，不能使用 main.js 中定义的 Vue 全局属性 this.$axios
import axios from 'axios'

export default {
  name: 'Navbar',  //this is the name of the component
  data () {
    return {
      sharedState: store.state
    }
  },
  methods: {
    handlerLogout (e) {
      store.logoutAction()
      this.$toasted.show('You have been logged out.', { icon: 'fingerprint' })
      this.$router.push('/login')
    }
  },
  mounted () {
    // 轮询 /api/users/<int:id>/notifications/ 请求用户的新通知
    $(function() {
      let since = 0
      let total_notifications_count = 0  // 总通知计数
      let unread_recived_comments_count = 0  // 收到的新评论通知计数

      setInterval(function() {
        if (window.localStorage.getItem('madblog-token')) {
          // 如果用户已登录，才开始请求 API
          const payload = JSON.parse(atob(window.localStorage.getItem('madblog-token').split('.')[1]))
          const user_id = payload.user_id
          const path = `/api/users/${user_id}/notifications/?since=${since}`
          axios.get(path)
            .then((response) => {
              // handle success
              for(var i = 0; i < response.data.length; i++) {
                switch (response.data[i].name) {
                  case 'unread_recived_comments_count':
                    unread_recived_comments_count = response.data[i].payload
                    break
                }
                since = response.data[i].timestamp
              }

              total_notifications_count = unread_recived_comments_count
              // 每一次请求之后，根据 total_notifications_count 的值来显示或隐藏徽标
              $('#new_notifications_count').text(total_notifications_count)
              $('#new_notifications_count').css('visibility', total_notifications_count ? 'visible' : 'hidden');
            })
            .catch((error) => {
              // handle error
              console.error(error)
            })
        }
      }, 10000)
    })
  }
}
</script>
```
**实现动态新评论通知，小结：**
1. 在models.py中class User实现
- 添加字段last_recived_comments_read_time:用户最后一次查看 收到的评论 页面的时间，用来判断哪些收到的评论是新的
- new_recived_comments():用户发布的文章下面收到的新评论计数
- add_notification():给用户实例对象增加通知
1. 每当有用户发表或删除评论时，都要给该文章的作者增加新评论通知，通知的名字为 unread_recived_comments_count，通知的 payload 只需要存储新评论的最新计数即可。
修改comments.py中的create_comment()和delete_comment()即可。

3. 最后在users.py中增加返回用户的新通知的API即可。

4. 前端Navbar组件通过时间轮询匹配到unread_recived_comments_count，则动态更新Bages徽章。
**注意：**后端要修改users.py中的get_comments()方法，注意分页情况，适当时机更新用户的last_recived_comments_read_time字段。


## 3. 其它用户通知
依葫芦画瓢，我们接着实现 新粉丝通知、新点赞通知、关注者的新文章通知，修改 back-end/app/models.py：

**实现新粉丝通知：**
1. 在models.py中class User实现
- 添加字段lasy_followes_read_time    # 用户最后一次查看 用户的粉丝 页面的时间，用来判断哪些粉丝是新的
- new_follows():用户的新粉丝计数

2. 每当你在关注或取消关注一个用户时，需要给该用户发送unread_follows_count 通知


**实现新点赞通知：**
1. 在models.py中class User实现
- 添加字段 last_likes_read_time：# 用户最后一次查看 收到的点赞 页面的时间，用来判断哪些点赞是新的
-new_likes():用户收到的新点赞计数

**实现关注者新发布的文章通知：**
1. 在models.py中class User实现
- 添加字段 last_followeds_posts_read_time： # 用户最后一次查看 关注的人的博客 页面的时间，用来判断哪些文章是新的
-  new_followeds_posts():用户关注的人新发布的文章计数