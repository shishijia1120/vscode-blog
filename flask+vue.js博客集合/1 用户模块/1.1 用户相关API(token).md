
## 2 数据库
### 2.1 ORM: SQLAlchemy
安装Flask-SQLAlchemy插件，还有数据表结构有变化进行迁移的Flask-Migrate插件。


修改配置文件back-end/config.py，默认使用SQLite数据库：
```python
import os
from dotenv import load_dotenv

basedir = os.path.abspath(os.path.dirname(__file__))
load_dotenv(os.path.join(basedir, '.env'))


class Config(object):
    SQLALCHEMY_DATABASE_URI = os.environ.get('DATABASE_URL') or \
        'sqlite:///' + os.path.join(basedir, 'app.db')
    SQLALCHEMY_TRACK_MODIFICATIONS = False

```
修改app/\__init__.py，引入并初始化插件：
```python
from flask import Flask
from flask_cors import CORS
from flask_sqlalchemy import SQLAlchemy
from flask_migrate import Migrate
from config import Config


# Flask-SQLAlchemy plugin
db = SQLAlchemy()
# Flask-Migrate plugin
migrate = Migrate()


def create_app(config_class=Config):
    app = Flask(__name__)
    app.config.from_object(config_class)

    # Enable CORS
    CORS(app)
    # Init Flask-SQLAlchemy
    db.init_app(app)
    # Init Flask-Migrate
    migrate.init_app(app, db)

    # 注册 blueprint
    from app.api import bp as api_bp
    app.register_blueprint(api_bp, url_prefix='/api')

    return app

```

### 2.2 定义User用户数据模型
创建app/models.py：
```python
from app import db


class User(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(64), index=True, unique=True)
    email = db.Column(db.String(120), index=True, unique=True)
    password_hash = db.Column(db.String(128))  # 不保存原始密码

    def __repr__(self):
        return '<User {}>'.format(self.username)
```

修改app/__init__.py，在文件末尾添加：
```pthon
from app import models
```
### 2.3 第一次数据库迁移

#### 2.4 存储用户密码的hash值
更新User数据模型：
```python
from werkzeug.security import generate_password_hash, check_password_hash
from app import db


class User(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(64), index=True, unique=True)
    email = db.Column(db.String(120), index=True, unique=True)
    password_hash = db.Column(db.String(128))  # 不保存原始密码

    def __repr__(self):
        return '<User {}>'.format(self.username)

    def set_password(self, password):
        self.password_hash = generate_password_hash(password)

    def check_password(self, password):
        return check_password_hash(self.password_hash, password)
```
> 配置Flask Shell上下文环境：
flask shell是启动一个Python解释器包含应用的上下文。


## 3. RESTful API设计
用户资源将暂时提供一下几个API
|HTTP方法|资源URL|说明|
|----|----|----|
|GET|/api/users|返回所有用户的集合|
|POST|/api/users|注册一个新用户|
|GET|/api/users/<id>|返回一个用户|
|PUT|/api/users/<id>|修改一个用户|
|DELETE|/api/users/<id>|删除一个用户|


创建app/api/users.py:
```python
from app.api import bp


@bp.route('/users', methods=['POST'])
def create_user():
    '''注册一个新用户'''
    pass


@bp.route('/users', methods=['GET'])
def get_users():
    '''返回所有用户的集合'''
    pass


@bp.route('/users/<int:id>', methods=['GET'])
def get_user(id):
    '''返回一个用户'''
    pass


@bp.route('/users/<int:id>', methods=['PUT'])
def update_user(id):
    '''修改一个用户'''
    pass


@bp.route('/users/<int:id>', methods=['DELETE'])
def delete_user(id):
    '''删除一个用户'''
    pass
```

修改app/api/\__inti__.py，在末尾添加：
```python
from app.api import ping, users
```

### 3.1 用户对象转换成JSON
后端Flask使用的都是User实例对象，而返回响应给前端时，需要传递JSON对象。修改app/models.py，给User数据模型添加to_dict方法：
```python
from flask import url_for
...

class User(db.Model):
    ...
    def to_dict(self, include_email=False):
        data = {
            'id': self.id,
            'username': self.username,
            '_links': {
                'self': url_for('api.get_user', id=self.id)
            }
        }
        if include_email:
            data['email'] = self.email
        return data
```

只有当用户请求自己的数据时才包含 email，使用 include_email 标志来确定该字段是否包含在字典中。后续调用该方法返回字典，再用 flask.jsonify 将字典转换成 JSON 响应。
转换过程：实例对象user——字典dict——json响应.

### 3.2 用户集合转换成JSON
设计一个通用类 PaginatedAPIMixin
```python
class PaginatedAPIMixin(object):
    @staticmethod
    def to_collection_dict(query, page, per_page, endpoint, **kwargs):
        resources = query.paginate(page, per_page, False)
        data = {
            'items': [item.to_dict() for item in resources.items],
            '_meta': {
                'page': page,
                'per_page': per_page,
                'total_pages': resources.pages,
                'total_items': resources.total
            },
            '_links': {
                'self': url_for(endpoint, page=page, per_page=per_page,
                                **kwargs),
                'next': url_for(endpoint, page=page + 1, per_page=per_page,
                                **kwargs) if resources.has_next else None,
                'prev': url_for(endpoint, page=page - 1, per_page=per_page,
                                **kwargs) if resources.has_prev else None
            }
        }
        return data
```
然后，User继承这个类：
```python
class User(PaginatedAPIMixin, db.Model):
    ...
```
### 3.3 JSON转换成用户对象
前端发送过来JSON对象，需要转换成User对象
```python
def from_dict(self, data, new_user=False):
    for field in ['username', 'email']:
        if field in data:
            setattr(self, field, data[field])
    if new_user and 'password' in data:
        self.set_password(data['password'])
```

### 3.4 错误处理
创建app/api/errors.py
```python
from flask import jsonify
from werkzeug.http import HTTP_STATUS_CODES


def error_response(status_code, message=None):
    payload = {'error': HTTP_STATUS_CODES.get(status_code, 'Unknown error')}
    if message:
        payload['message'] = message
    response = jsonify(payload)
    response.status_code = status_code
    return response


def bad_request(message):
    '''最常用的错误 400：错误的请求'''
    return error_response(400, message)
```
### 3.5 注册新用户
```python
import re
from flask import request, jsonify, url_for
from app import db
from app.api import bp
from app.api.auth import token_auth
from app.api.errors import bad_request
from app.models import User


@bp.route('/users', methods=['POST'])
def create_user():
    '''注册一个新用户'''
    data = request.get_json()
    if not data:
        return bad_request('You must post JSON data.')

    message = {}
    if 'username' not in data or not data.get('username', None):
        message['username'] = 'Please provide a valid username.'
    pattern = '^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$'
    if 'email' not in data or not re.match(pattern, data.get('email', None)):
        message['email'] = 'Please provide a valid email address.'
    if 'password' not in data or not data.get('password', None):
        message['password'] = 'Please provide a valid password.'

    if User.query.filter_by(username=data.get('username', None)).first():
        message['username'] = 'Please use a different username.'
    if User.query.filter_by(email=data.get('email', None)).first():
        message['email'] = 'Please use a different email address.'
    if message:
        return bad_request(message)

    user = User()
    user.from_dict(data, new_user=True)
    db.session.add(user)
    db.session.commit()
    response = jsonify(user.to_dict())
    response.status_code = 201
    # HTTP协议要求201响应包含一个值为新资源URL的Location头部
    response.headers['Location'] = url_for('api.get_user', id=user.id)
    return response
```

## 4. API认证
为了简化使用 token 认证时客户端和服务器之间的交互，可以使用 Flask-HTTPAuth 插件
```
(venv) D:\python-code\flask-vuejs-madblog\back-end>pip install flask-httpauth
(venv) D:\python-code\flask-vuejs-madblog\back-end>pip freeze > requirements.txt
```
当客户端想要开始与 API 交互时，它需要使用用户名和密码进行 Basic Auth 验证，然后获得一个临时 token。只要 token 有效，客户端就可以发送附带 token 的 API 请求以通过认证。一旦 token 到期，需要申请新的 token

### 4.1 User数据模型添加token
修改app/models.py:
```python
class User(PaginatedAPIMixin, db.Model):
    ...
    token = db.Column(db.String(32), index=True, unique=True)
    token_expiration = db.Column(db.DateTime)
    ...

    def get_token(self, expires_in=3600):
        now = datetime.utcnow()
        if self.token and self.token_expiration > now + timedelta(seconds=60):
            return self.token
        self.token = base64.b64encode(os.urandom(24)).decode('utf-8')
        self.token_expiration = now + timedelta(seconds=expires_in)
        db.session.add(self)
        return self.token

    def revoke_token(self):
        self.token_expiration = datetime.utcnow() - timedelta(seconds=1)

    @staticmethod
    def check_token(token):
        user = User.query.filter_by(token=token).first()
        if user is None or user.token_expiration < datetime.utcnow():
            return None
        return user
```


### 4.2 HTTP Bssic Authentication
创建app/api/auth.py:
```python
from flask import g
from flask_httpauth import HTTPBasicAuth
from app.models import User
from app.api.errors import error_response

basic_auth = HTTPBasicAuth()


@basic_auth.verify_password
def verify_password(username, password):
    '''用于检查用户提供的用户名和密码'''
    user = User.query.filter_by(username=username).first()
    if user is None:
        return False
    g.current_user = user
    return user.check_password(password)


@basic_auth.error_handler
def basic_auth_error():
    '''用于在认证失败的情况下返回错误响应'''
    return error_response(401)
```

### 4.3 客户端申请Token
现在我已经实现了 Basic Auth 验证的支持，因此我可以添加一条 token 检索路由，以便客户端在需要 token 时调用

创建 app/api/tokens.py：
```python
from flask import jsonify, g
from app import db
from app.api import bp
from app.api.auth import basic_auth


@bp.route('/tokens', methods=['POST'])
@basic_auth.login_required
def get_token():
    token = g.current_user.get_token()
    db.session.commit()
    return jsonify({'token': token})
```
装饰器 @basic_auth.login_required 将指示 Flask-HTTPAuth 验证身份，当通过 Basic Auth 验证后，才使用用户模型的 get_token() 方法来生成 token，数据库提交在生成 token 后发出，以确保 token 及其到期时间被写回到数据库

修改 app/api/__init__.py，在末尾添加：
```python
from app.api import ping, users, tokens
```

### 4.4 HTTP Token Authrntication
用户通过 Basic Auth 拿到 token 后，之后的请求只要附带这个 token 就能够访问其它 API，修改 app/api/auth.py：

```python
from flask_httpauth import HTTPBasicAuth, HTTPTokenAuth
...

token_auth = HTTPTokenAuth()
...

@token_auth.verify_token
def verify_token(token):
    '''用于检查用户请求是否有token，并且token真实存在，还在有效期内'''
    g.current_user = User.check_token(token) if token else None
    return g.current_user is not None


@token_auth.error_handler
def token_auth_error():
    '''用于在 Token Auth 认证失败的情况下返回错误响应'''
    return error_response(401)
```

### 4.5 使用Token机制保护API路由
除 create_user() 之外的所有 API 视图函数需要添加 @token_auth.login_required 装饰器，显而易见，这个函数不能使用 token 认证，因为用户都不存在时，更不会有 token 了

```python
@bp.route('/users', methods=['GET'])
@token_auth.login_required
def get_users():
    ...

@bp.route('/users/<int:id>', methods=['GET'])
@token_auth.login_required
def get_user(id):
    ...

...
```

### 4.6 撤销Token
修改 app/api/tokens.py：
```python
from app.api.auth import basic_auth, token_auth
...

@bp.route('/tokens', methods=['DELETE'])
@token_auth.login_required
def revoke_token():
    g.current_user.revoke_token()
    db.session.commit()
    return '', 204
```