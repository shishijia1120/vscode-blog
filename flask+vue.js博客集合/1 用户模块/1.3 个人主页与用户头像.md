## 1. JWT

上一篇文章通过后端创建 Token 并保存到数据库中（同时记录 Token 的失效时间），结合 Flask-HTTPAuth 插件实现 Basic Auth 和 Token Auth。但是，前端用户登录后，并不知道自己的用户 id，就没办法调用 GET /api/users/<id> 来获取自己的用户信息
### 1.1 pyjwt
现在改用 JWT 实现，它可以在 Token 中添加一些不是隐私的数据 payload，比如我们可以把用户 id 放进去。后端安装 pyjwt 包：
```
(venv) D:\python-code\flask-vuejs-madblog\back-end>pip install pyjwt
(venv) D:\python-code\flask-vuejs-madblog\back-end>pip freeze > requirements.txt
```
修改 User 数据模型 back-end/app/models.py，删除之前的 token 和 token_expiration 字段：
```python
class User(PaginatedAPIMixin, db.Model):
    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(64), index=True, unique=True)
    email = db.Column(db.String(120), index=True, unique=True)
    password_hash = db.Column(db.String(128))  # 不保存原始密码
    ...

    def get_jwt(self,expires_in=600):
        now=datetime.utcnow()
        payload={
             'user_id': self.id,
            'name': self.name if self.name else self.username,
            'exp': now + timedelta(seconds=expires_in),
            'iat': now
        }
         return jwt.encode(
            payload,
            current_app.config['SECRET_KEY'],
            algorithm='HS256').decode('utf-8')
    
    @staticmethod
    def verify_jwt(token):
        try:
            payload = jwt.decode(
                token,
                current_app.config['SECRET_KEY'],
                algorithms=['HS256'])
        except (jwt.exceptions.ExpiredSignatureError, jwt.exceptions.InvalidSignatureError) as e:
            # Token过期，或被人修改，那么签名验证也会失败
            return None
        return User.query.get(payload.get('user_id'))
 

    
```
在配置文件 back-end/config.py 中添加配置项: SECRET_KEY = os.environ.get('SECRET_KEY') or 'you-will-never-guess'

修改 back-end/app/api/tokens.py：
```python
from flask import jsonify, g
from app import db
from app.api import bp
from app.api.auth import basic_auth


@bp.route('/tokens', methods=['POST'])
@basic_auth.login_required
def get_token():
    token = g.current_user.get_jwt()
    db.session.commit()
    return jsonify({'token': token})
```
注意： JWT 没办法回收（不需要 DELETE /tokens），只能等它过期，所以有效时间别设置太长


### 1.3 JSON.parse
前端用户在登录页面输入用户名和密码后，axios 调用 POST /tokens。后端首先要进行 Basic Auth 认证， 如果用户名和密码正确，则进入视图函数 get_token 中执行并返回 JWT 给前端

用户 id 存放在 JWT 的第二部分中（三个部分以点号 . 分隔），所以前端可以使用如下方法解析 JSON 数据：
```javascript
export default {
  debug: true,
  state: {
    is_authenticated: window.localStorage.getItem('madblog-token') ? true : false,
    // 用户登录后，就算刷新页面也能再次计算出 user_id
    user_id: window.localStorage.getItem('madblog-token') ? JSON.parse(atob(window.localStorage.getItem('madblog-token').split('.')[1])).user_id : 0
  },
  loginAction () {
    if (this.debug) { console.log('loginAction triggered') }
    this.state.is_authenticated = true
    this.state.user_id = JSON.parse(atob(window.localStorage.getItem('madblog-token').split('.')[1])).user_id
  },
  logoutAction () {
    if (this.debug) console.log('logoutAction triggered')
    window.localStorage.removeItem('madblog-token')
    this.state.is_authenticated = false
    this.state.user_id = 0
  }
}
```

## 3.axios 全局配置
### 3.1 Base URL
前端如果每次通过 axios 调用后端 API 时，指定的 API URL都写死到各个组件中，现在开发环境是类似 http://localhost:5000/api/users/1 这样的，如果后续部署到生产环境上，可能IP和端口会变动，所以可以通过 axios 全局配置一次指定

创建 front-end/src/http.js：
```javascript
import axios from 'axios'
...

// 基础配置
axios.defaults.timeout = 5000  // 超时时间
axios.defaults.baseURL = 'http://localhost:5000/api'

export default axios
```
 
 然后在 front-end/src/main.js 中引入它：
 ```javascript
 // 导入配置了全局拦截器后的 axios
import axios from './http'
...

// 将 $axios 挂载到 prototype 上，在组件中可以直接使用 this.$axios 访问
Vue.prototype.$axios = axios
 ```

### 3.2 Request Interceptor
用户以后访问后端需要认证的 API 时都要传输 Token，而 axios 可以通过创建 request interceptor 自动帮你添加 Token 到请求头 Authorization 中：

修改front-end/src/http.js，添加：
```javascript
// Add a request interceptor
axios.interceptors.request.use(function (config) {
  // Do something before request is sent
  const token = window.localStorage.getItem('madblog-token')
  if (token) {
    config.headers.Authorization = `Bearer ${token}`
  }
  return config
}, function (error) {
  // Do something with request error
  return Promise.reject(error)
})
```

### 3.3  Response Interceptor
前面说过 JWT 的有效期要设置的短一些，当它过期后，用户再通过它访问后端 API 时会返回 401 UNAUTHORIZED 错误，我们希望 axios 自动处理这个错误，如果用户当前访问的不是 /login 路由（正常登录）时，会自动跳转到登录页，要求用户重新认证

修改front-end/src/http.js，添加:
```javascript
// Add a response interceptor
axios.interceptors.response.use(function (response) {
  // Do something with response data
  return response
}, function (error) {
  // Do something with response error
  switch  (error.response.status) {
    case 401:
      // 清除 Token 及 已认证 等状态
      store.logoutAction()
      // 跳转到登录页
      if (router.currentRoute.path !== '/login') {
        Vue.toasted.error('401: 认证已失效，请先登录', { icon: 'fingerprint' })
        router.replace({
          path: '/login',
          query: { redirect: router.currentRoute.path },
        })
      }
      break

    case 404:
      Vue.toasted.error('404: NOT FOUND', { icon: 'fingerprint' })
      router.back()
      break
  }
  return Promise.reject(error)
})

export default axios
```