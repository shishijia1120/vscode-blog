# 权限管理
## 1. 角色Role
> 重点在于permissions的实现方法，比较新鲜。

每个角色可以拥有多个用户，所以Role和User是一对多关系。
### 1.1 定义模型
models.py:
```python
class Permission:
 # 关注其它用户的权限
    FOLLOW = 0x01
    # 发表评论、评论点赞与踩的权限
    COMMENT = 0x02
    # 撰写文章的权限
    WRITE = 0x04
    # 管理网站的权限(对应管理员角色)
    ADMIN = 0x80

class Role(PaginatedAPIMixin,db.Model):
    __tablename__='roles'
     id = db.Column(db.Integer, primary_key=True)
    slug = db.Column(db.String(255), unique=True)
    name = db.Column(db.String(255))  # 角色名称
    default = db.Column(db.Boolean, default=False, index=True)  # 当新增用户时，是否将当前角色作为默认角色赋予新用户
    permissions = db.Column(db.Integer)  # 角色拥有的权限，各操作对应一个二进制位，能执行某项操作的角色，其位会被设为 1
    users = db.relationship('User', backref='role', lazy='dynamic')

    def __init__(self, **kwargs):
        super(Role, self).__init__(**kwargs)
        if self.permissions is None:
            self.permissions = 0

    @staticmethod
    def insert_roles():
        '''应用部署时，应该主动执行此函数，添加以下角色
        注意: 未登录的用户，可以浏览，但不能评论或点赞等
        shutup:        0b0000 0000 (0x00) 用户被关小黑屋，收回所有权限
        reader:        0b0000 0011 (0x03) 读者，可以关注别人、评论与点赞，但不能发表文章
        author:        0b0000 0111 (0x07) 作者，可以关注别人、评论与点赞，发表文章
        administrator: 0b1000 0111 (0x87) 超级管理员，拥有全部权限

        以后如果要想添加新角色，或者修改角色的权限，修改 roles 数组，再运行函数即可
        '''
        roles = {
            'shutup': ('小黑屋', ()),
            'reader': ('读者', (Permission.FOLLOW, Permission.COMMENT)),
            'author': ('作者', (Permission.FOLLOW, Permission.COMMENT, Permission.WRITE)),
            'administrator': ('管理员', (Permission.FOLLOW, Permission.COMMENT, Permission.WRITE, Permission.ADMIN)),
        }
        default_role = 'reader'
        for r in roles:  # r 是字典的键，比如 'reader'
            role = Role.query.filter_by(slug=r).first()
            if role is None:
                role = Role(slug=r, name=roles[r][0])
            role.reset_permissions()
            for perm in roles[r][1]:
                role.add_permission(perm)
            role.default = (role.slug == default_role)
            db.session.add(role)
        db.session.commit()

    def reset_permissions(self):
        self.permissions = 0

    def has_permission(self, perm):
        return self.permissions & perm == perm

    def add_permission(self, perm):
        if not self.has_permission(perm):
            self.permissions += perm

    def remove_permission(self, perm):
        if self.has_permission(perm):
            self.permissions -= perm

    def __str__(self):
        return self.name

    def __repr__(self):
        return '<Role {}>'.format(self.name)
    
```

## 1.2 初始化角色表
若想把角色写入数据库，可使用 flask shell 会话，首先需要修改 back-end/madblog.py，在 shell 上下文中增加 Role：
```python
from app.models import Role
...

@app.shell_context_processor
def make_shell_context():
    return {'db': db, 'Role': Role, 'User': User, 'Post': Post, 'Comment': Comment,
            'Notification': Notification, 'Message': Message}
```
然后执行flask shell命令：
```python
(venv) D:\python-code\flask-vuejs-madblog\back-end>flask shell
Python 3.6.1 (v3.6.1:69c0db5, Mar 21 2017, 17:54:52) [MSC v.1900 32 bit (Intel)] on win32
App: app [production]
Instance: D:\python-code\flask-vuejs-madblog\back-end\instance
>>> Role.insert_roles()
>>> Role.query.all()
[<Role 小黑屋>, <Role 读者>, <Role 作者>, <Role 管理员>]
```
### 1.3 赋予角色
因为我们创建新用户的 API 中是使用 User.from_dict(self, data, new_user=True)，所以不能把自动分配用户角色的逻辑代码放到 User.__init__() 中，那样的话会先执行 __init__()，而此时 self.email 永远是 None，所以下面的代码是错误的：
```python
class User(PaginatedAPIMixin, db.Model):
    ...
    def __init__(self, **kwargs):
        '''给用户自动分配角色'''
        super(User, self).__init__(**kwargs)
        if self.role is None:
            if self.email in current_app.config['ADMINS']:
                self.role = Role.query.filter_by(name='administrator').first()
            else:
                self.role = Role.query.filter_by(default=True).first()
    ...
```
正确的代码应该是，修改models.py:
```python
class User(PaginatedAPIMixin, db.Model):
    ...
    def from_dict(self, data, new_user=False):
        for field in ['username', 'email', 'name', 'location', 'about_me']:
            if field in data:
                setattr(self, field, data[field])
        if new_user and 'password' in data:
            self.set_password(data['password'])
            # 新建用户时，给用户自动分配角色
            if self.role is None:
                if self.email in current_app.config['ADMINS']:
                    self.role = Role.query.filter_by(slug='administrator').first()
                else:
                    self.role = Role.query.filter_by(default=True).first()
```

## 2. 角色验证
> 重点再自定义的装饰器

现在用户有了对应的角色，在调用 API 时我们就只需要检查此用户是否有对应的操作权限即可
```python
class User(PaginatedAPIMixin, db.Model):
    ...
    def can(self, perm):
        '''检查用户是否有指定的权限'''
        return self.role is not None and self.role.has_permission(perm)

    def is_administrator(self):
        '''检查用户是否为管理员'''
        return self.can(Permission.ADMIN)
```
User 模型中添加的 can() 方法在请求和赋予角色这两种权限之间进行 位与 操作。如果角色中包含请求的所有权限位，则返回 True，表示允许用户执行此项操作。检查管理员权限的功能经常用到，因此使用单独的方法 is_administrator() 实现

如果你想让 API 只对具有特定权限的用户开放，可以使用自定义的 装饰器。下面的代码实现了两个装饰器，一个用来检查常规权限，一个专门用来检查管理员权限

创建 back-end/app/utils/decorator.py：
> 为什么要将检查常规权限和管理员权限
```python
from functools import wraps
from flask import g
from app.api.errors import error_response
from app.models import Permission


def permission_required(permission):
    '''检查常规权限'''
    def decorator(f):
        @wraps(f)
        def decorated_function(*args, **kwargs):
            if not g.current_user.can(permission):  # 用户通过了Basic Auth认证后，就会在当前会话中附带 g.current_user
                return error_response(403)
            return f(*args, **kwargs)
        return decorated_function
    return decorator


def admin_required(f):
    '''检查管理员权限'''
    return permission_required(Permission.ADMIN)(f)
```

### 2.1 发表文章的权限
修改 back-end/app/api/posts.py，再添加 @permission_required(Permission.WRITE) 装饰器即可：
```python
from app.models import Permission
from app.utils.decorator import permission_required
...

@bp.route('/posts/', methods=['POST'])
@token_auth.login_required
@permission_required(Permission.WRITE)
def create_post():
    '''添加一篇新文章'''
    ...
```
> 注意： 两个装饰器的先后顺序！

### 2.2 删除文章的权限
之前的实现是只有文章的作者才能够删除此文章，而实际的管理中，如果用户发表了敏感的文章，管理员可以删除它，只需要修改 back-end/app/api/posts.py 中的 delete_post() 即可：
```python
@bp.route('/posts/<int:id>', methods=['DELETE'])
@token_auth.login_required
def delete_post(id):
    '''删除一篇文章'''
    post = Post.query.get_or_404(id)
    if g.current_user != post.author and not g.current_user.can(Permission.ADMIN):  # 管理员也可以删除文章
        return error_response(403)
    db.session.delete(post)
    # 给文章作者的所有粉丝发送新文章通知(需要自动减1)
    for user in post.author.followers:
        user.add_notification('unread_followeds_posts_count',
                              user.new_followeds_posts())
    db.session.commit()
    return '', 204
```
### 2.3 关注/取消关注的权限
修改 back-end/app/api/users.py，再添加 @permission_required(Permission.FOLLOW) 装饰器即可：

```python
from app.models import Permission
from app.utils.decorator import permission_required
...

###
# 关注 / 取消关注
###
@bp.route('/follow/<int:id>', methods=['GET'])
@token_auth.login_required
@permission_required(Permission.FOLLOW)
def follow(id):
    '''开始关注一个用户'''
    ...

@bp.route('/unfollow/<int:id>', methods=['GET'])
@token_auth.login_required
@permission_required(Permission.FOLLOW)
def unfollow(id):
    '''取消关注一个用户'''
    ...


###
# 拉黑 / 取消拉黑
###
@bp.route('/block/<int:id>', methods=['GET'])
@token_auth.login_required
@permission_required(Permission.FOLLOW)
def block(id):
    '''开始拉黑一个用户'''
    ...

@bp.route('/unblock/<int:id>', methods=['GET'])
@token_auth.login_required
@permission_required(Permission.FOLLOW)
def unblock(id):
    '''取消拉黑一个用户'''
    ...
```


## 3. 前端优化
然后，假设用户已经登录了。如果它只是一个读者角色，那么不应该显示发表文章的表单。前端用户访问 http://127.0.0.1:8080/#/login 路由时，会请求后端的 /api/tokens，我们现在需要像之前回传用户ID、用户头像地址一样，将 用户的操作权限列表 也放入 Token 中返回给前端
>注意： 不能返回用户的角色，因为后续在后台管理中可以修改某个角色的操作权限的，比如将 reader 的 Permission.FOLLOW 去除

首先需要获取一个角色对应的操作权限列表，修改 back-end/app/models.py：
```python
class Role(PaginatedAPIMixin, db.Model):
    ...
    def get_permissions(self):
        '''获取角色的具体操作权限列表'''
        p = [(Permission.FOLLOW, 'follow'), (Permission.COMMENT, 'comment'), (Permission.WRITE, 'write'), (Permission.ADMIN, 'admin')]
        # 过滤掉没有权限，注意不能用 for 循环，因为遍历列表时删除元素可能结果并不是你想要的，参考: https://segmentfault.com/a/1190000007214571
        new_p = filter(lambda x: self.has_permission(x[0]), p)
        return ','.join([x[1] for x in new_p])  # 用逗号拼接成str
```

然后，在生成 JWT Token 时附带这个权限列表字符串，修改 back-end/app/models.py：
```python
class User(PaginatedAPIMixin, db.Model):
    ...
    def get_jwt(self, expires_in=3600):
        '''用户登录后，发放有效的 JWT'''
        now = datetime.utcnow()
        payload = {
            'user_id': self.id,
            'confirmed': self.confirmed,
            'user_name': self.name if self.name else self.username,
            'user_avatar': base64.b64encode(self.avatar(24).
                                            encode('utf-8')).decode('utf-8'),
            'permissions': self.role.get_permissions(),
            'exp': now + timedelta(seconds=expires_in),
            'iat': now
        }
        return jwt.encode(
            payload,
            current_app.config['SECRET_KEY'],
            algorithm='HS256').decode('utf-8')
```
然后需要修改 front-end/src/store.js，存储用户的角色信息：
> 重点怎么正确获取token携带的user_perms?
```javascript
export default {
  debug: true,
  state: {
    ...
    // 用户登录后，就算刷新页面也能再次计算出 user_perms
    user_perms: window.localStorage.getItem('madblog-token') ? JSON.parse(atob(window.localStorage.getItem('madblog-token').split('.')[1])).permissions.split(",") : ''
  },
  loginAction () {
    ...
    this.state.user_perms = payload.permissions.split(",")  // 转换成数组
  },
  logoutAction () {
    ...
    this.state.user_perms = ''
  }
}
```
> 现在用户的操作权限就存储在 store.state.user_perms 数组中了，比如要判断登录的用户有没有 admin 权限，只需要使用 JS 数组的 includes() 方法即可

> 至于如何完善整个系统的其它操作权限，就留给读者自己去完成了。另外，由于 JWT 不能主动被销毁，假设目前 Token 发放后 1 小时后过期，如果期间修改了用户所属的角色对应的操作权限的话，前端应用是无法实时更新的，因为它拿到的 Token 中附带的权限列表没有变。此时，我们只需要重新注销登录后，再重新登录一次即可，因为用户每次登录时都会调用 /api/tokens，而它又会执行 get_jwt()，会重新生成新的 Token (包含最新的操作权限列表)