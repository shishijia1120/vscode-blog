## 12 类和动态内存分配


### 12.1 动态内存和类

```
class StringBad
{
    private:
        char * str;
        int len;
        static int num_strings;
    public:
        StringBad(const char * s);
        StringBad();
        ~StringBad();
        friend std::ostream & operator<<(std::ostream & os,const StringBad & st);
};
# endif
```
对于这个说明，需要注意的有两点。首先，它使用char指针(而不是char数组)来表示姓名。这意味着类声明没有为字符串本身分配存储空间，而是在构造函数中使用new来为字符串分配空间。这避免了在类声明中预先定义字符串的长度。

其次，将num_strings成员声明为静态存储类。静态类成员有一个特点：无论创建了多少对象，程序都只创建一个静态类变量副本。也就是说，类的所有对象共享同一个静态成员。

```
#include "stringbad.h"

int StringBad:;num_strings = 0;

StringBad::StringBad(const char * s)
{
    len=std::strlen(s);
    str = new char[len+1];
    std::strcpy(str,s);
    num_strings++;
    cout<<num_strings<<":\"<<str
        <<"\" object created\n";
}


StringBad::StringBad()
{
    len=4;
    str=new char[4];
    std::strcpy(str,"C++");
    num_strings++;
    cout<<num_strings<<":\"<<str
        <<"\"default object created\n";
}

StringBad::~StringBad()
{
    cout<<"\" <<str << "\" object deleted,";
    --num_strings;
    cout<<num_strings <<"left \n";
    delete [] str;
}

std::ostream & operator <<(std::ostream & os,const StringBad & st)
{
    os << st.str;
    return os;
}
```

```
int StringBad::num_strings = 0;
```
这条语句将静态成员num_strings的值初始化为0。请注意，不能在类声明中初始化静态成员变量，这是因为声明描述了如何分配内存，但并不分配内存。你可以使用这种格式来创建对象，从而分配和初始化内存。对于静态类成员，可以在类声明之外使用单独的语句进行初始化。这是因为静态类成员是单独存储的，而不是对象的组成部分。请注意，初始化语句指出了类型，并使用了作用域运算符，但没有使用关键字static。

初始化是在方法文件中，而不是类声明文件中进行的，这是因为类声明位于头文件中，程序可能将头文件包括在其他几个文件中。如果在头文件中进行初始化，将出现多个初始化语句副本，从而引发错误。

对于不能在类声明中初始化静态数据成员的一种例外情况是(见第10章)是，静态数据成员为整型或枚举型const。

**注意：** 静态数据成员在类声明中声明，在包含类方法的文件中初始化。初始化时使用作用域运算符来指出静态数据成员所属的类。但如果静态成员是整型或枚举型const，则可以在类声明中初始化。




现在来看第一个构造函数，它使用一个常规C字符串来初始化String对象：
```
StringBad::StringBad(const char * s)
{
    len=std::strlen(s);
    str = new char[len+1];
    std::strcpy(str,s);
    num_strings++;
    cout<<num_strings<<":\"<<str
        <<"\" object created\n";
}
```

首先，shiy strlen()函数计算字符串的长度，并对len成员进行初始化。接着，使用new分配足够的空间来保持字符串，然后将新内存的地址赋给str成员。(strlen()返回字符串长度，但不包括末尾的空字符，因此构造函数将len加1，使分配的内存能够存储包含空字符的字符串。)

接着，构造函数使用strcpy()将传递的字符串复制到新的内存中，并更新对象技术。最后，构造函数显示当前的对象数目和当前对象中存储的字符串，以助于掌握程序运行情况。

要理解这种方法，必须知道字符串并不保存在对象中。字符串单独保存在堆内存中，对象仅保存了指出到哪里去查找字符串的信息。

不能这样做：
```
str = s;
```
这只保存了地址，而没有创建字符串副本。

默认构造函数与此相似，但它提供了一个默认字符串:"C++"。

```
StringBad::~StringBad()
{
    cout<<"\" <<str << "\" object deleted,";
    --num_strings;
    cout<<num_strings <<"left \n";
    delete [] str;
}

```
该析构函数首先指出自己何时被调用。这部分包含了丰富的信息，但并不是必不可少的。然而，delete语句却是至关重要的。str成员指向new分配的内存。当StringBad对象过期时，str指针也将过期。但str指向的内存仍被分配，除非使用delete将其释放。删除对象可以释放对象本身占用的内存，但并不能自动释放属于对象成员的指针指向的内存。因此，必须使用析构函数。在析构函数中使用delete语句可确保对象过期时，由构造函数使用new分配的内存被释放。

**警告：** 在构造函数中使用new来分配内存时，必须在相应的析构函数中使用delete来释放内存。如果使用new[](包括中括号)来分配内存，则应使用delete[](包括中括号)来释放内存。


vegnews.cpp:
```
#include "stringbad.h"

void callme1(StringBad &); //pass by reference
void callme2(StringBad);  // pass by value

int main()
{
    using std::endl;
    {
        cout<<Starting an inner block:\n";
        StringBad headline1("celery");
        StringBad headline2("lettuce");
        StringBad sports("spinach");
        
        cout<<"headline1:"<<headline1<<endl;
        cout<<"headline2:"<<headline2<<endl;
        cout<<"sports:"<<sports<<endl;

        callme1(headline1);
        cout<<"headline1:"<<headline1<<endl;
        callme2(headline2);
        cout<<"headline2:"<<headline2<<endl;

        cout<<"Initialize one object to anothor:\n";
        StringBad sailor = sports;
        cout<<"Sailor:"<<sailor<<endl;

        cout<<"Assign one object to anothor:\n";
        StringBad knot; 
        knot = headline1;
        cout<<"knot:"<<knot<<endl;
        cout<<"Exiting the block.\n";
    }

    cout<<"End of main()\n";

    return 0;
}

void callme1(SringBad & rsb)
{
    cout<<"String passed by reference:\n";
    cout<<"  \" "<< rsb <<"\"\n";
}

void callme2(StringBad sb)
{
    cout<<"String passed by value:\n";
    cout<<"  \" "<< sb <<"\"\n";
}
```
运行结果：
```
Starting an inner block.
1: "celery" object created
2. "lettuce" object created
3. "spinach" object created
headline1:celery
headline2:lettuce
sports:spinach

String passed by reference:
    "celery"
headline1:celery

String passed by value:
    "lettuce"
"lettuce" object deleted, 2 left
headline2:Du

Initialize one object to anothor:
sailor:spinach

Assign one object to anothor:
3:"C++" default object created
knot:celery

Exiting the block

"celery" object deleted, 2 left
"spinach" obkect deleted, 1 left
"spinach" deleted, 0 left
"@g" object deleted, -l left
"-|" object deleted, -2 left
End of main()
```

。。。

##### 程序说明
。。。
然后，程序将headline1传递给callme1()函数，并在调用后重新显示headline1。代码如下：
```
callme1(headline1);
cout<<"headline1:"<<headline1<<endl;
```
下面是运行结果：
```
String passed by reference:
    "celery"
headline1:celery
```
这部分代码看起来正常。
但随后程序执行了如下代码：
```
callme2(headline2);
cout<<"headline2:"<<headline2<<endl;
```
这里，callme2()按值(而不是按引用)传递headline2，结果表明这是一个严重的问题!
```
String passed by value:
    "lettuce"
"lettuce" object deleted, 2 left
headline2:Du
```
首先，将headline2作为函数参数来传递从而导致析构函数被调用。其次，虽然按值传递可以防止原始参数被修改，但实际上函数以使原始字符无法识别，导致显示一些非标准字符(显示的文本取决于内存这包含的内容)。

请看输出结果，在为每一个创建的对象自动调用析构函数时，情况更糟糕：
```
Exiting the block:
"celery" object deleted, 2 left
"spinach"  object deleted, 1 left
"spinach" object deleted, 0 left
"@g" object deleted, -1 left
"-|" object deleted, -2 left
End of main()
```

因为自动存储对象被删除的顺序与创建顺序相反，所有最先删除的3个对象是knots、sailor和sport。删除knots和sailor时是正常的，但在删除sports时，Dollars变成了Doll8。

对于sports，程序只使用它来初始化sailor，但这种操作修改了sports。最后删除的两个对象(headline2和headline1)已经无法识别。这些字符串在被删除之前，有些操作将它们搞乱了。另外，计数也很奇怪，如何会余下-2个对象呢？

实际上，计数异常是一条线索。因为每个对象被构造和析构一次，因此调用构造函数的次数应当与析构函数的调用次数相同。对象计数递减的次数比递增次数多2，这表明使用了不将num_string递增的构造函数创建了两个对象。类定义声明并定义了两个构造函数(这两个构造函数都使num_string递增)，但结果表明程序使用了3个构造函数。例如，请看下面的代码：
```
StringBad sailor = sports;
```
这使用的是哪个构造函数呢？不是默认构造函数，也不是参数为const char * 的构造函数。记住，这种形式的初始化等效于下面的语句：
```
StringBad sailor=StringBad(sports); //constructor using sports
```
因为sports的类型为StringBad，因此相应的构造函数原型应该如下：
```
StringBad(const StringBad &);
```
当你使用一个对象初始化另一个对象时，编译器将自动生成上述构造函数(称为复制构造函数，因为它为创建对象的一个副本)。自动生成的构造函数不知道需要更新静态变量num_strings，因此会将计数方案搞乱。实际上，这个例子说明的所有问题都是以编译器自动生成的成员函数引起的。下面介绍这个主题。
#### 1.2 特殊成员函数
StringBad类的问题是由特殊成员函数引起的。这些成员函数是自动定义的，就StringBad而言，这些函数的行为与类设计不符。具体来说，C++自动提供了下面这些成员函数：
- 默认构造函数，如果没有定义构造函数；
- 默认析构函数，如果没有定义；
- 复制构造函数，如果没有定义；
- 复制运算符，如果没有定义；
- 地址运算符，如果没有定义。

结果表明，StringBad类中的问题是由隐式复制构造函数和隐式赋值运算符引起的。

##### 1.默认构造函数

。。。

##### 2. 复制构造函数
复制构造函数用于将一个对象复制到新创建的对象中。也就是说，它用于初始化过程中(包括按值传递参数)，而不是常规的赋值过程中。类的复制构造函数原型通常如下：
```
Class_name(const Class_name &);
```
它接受一个指向类对象的常量引用作为参数。例如，String类的复制构造函数的原型如下：
```
StringBad(const StringBad &);
```
对于复制构造函数，需要知道两点：何时调用和有何功能。

##### 3. 何时调用复制构造函数
新建一个对象并将其初始化为同类现有对象时，复制构造函数都将被调用。这在很多情况下都可能发生，最常见的情况是将新对象显示地初始化为现有的对象。例如，假设motto是一个StringBad对象，则下面4种声明都将调用复制构造函数：
```
StringBad ditto(motto);  // calls StringBad(const StringBad &)
StringBad metto = motto; // calls StringBad(const StringBad &)
StringBad also = StringBad(mott0);
                         // calls StringBad(const StringBad &)
StringBad * pStringBad = new StringBad(motto);
                        // calls StringBad(const StringBad &)

```
其中中间的2种声明可能会使用复制构造函数直接创建metoo和also，也可能会使用复制构造函数生成一个临时对象，然后将临时对象的内容赋给metto和also，这取决于具体的实现。最后一种声明使用motto初始化一个匿名对象，并将新对象的地址赋给pstring指针。

每当程序生成了对象副本时，编译器都将使用复制构造函数。具体地说，当函数按值传递对象(如callme2()或函数返回对象时，都将使用复制构造函数。记住，按值传递意味着创建原始变量的一个副本。编译器生成临时对象时，也将使用复制构造函数。例如，将3个Vector对象相加时，编译器可能会生成临时的Vector对象来保存中间结果。何时生成临时对象随编译器而异，但无论是哪种编译器，当按值传递和返回对象时，都将调用复制构造函数，具体来说，callme2()函数将调用下面的复制构造函数：
```
callme2(headline2);
```
程序使用复制构造函数初始化sb——callme2()函数的StringBad型形参。

由于按值传递对象将调用复制复制构造函数，因此应该调用按引用传递对象。这样可以节省调用函数的时间以及存储新对象的空间。

##### 4. 默认的复制构造函数的功能
默认的复制构造函数逐个复制非静态成员(成员复制也称为浅复制)，复制的是成员的值。下述语句：
```
StringBad sailor = sports;
```
与下面的代码等效(只是由于私有成员是无法访问的，因此这些代码不能通过编译)：
```
StringBad sailor;
sailor.str = sports.str;
sailor.len=sports.len;
```
如果成员本身就是类对象，则将使用这个类的复制构造函数来复制成员对象。静态函数(如num_strings)不受影响，因为它们属于整个类，而不是各个对象。
       
#### 1.3 回到StringBad:复制构造函数的哪里出了问题
现在介绍程序中的两个异常之处(假设输出为该程序清单后面列出的)。首先，程序的输出表明，析构函数的调用次数比构造函数的调用次数多2，原因可能是程序确实使用默认的构造函数另外创建了两个对象。当callme2()被调用时，复制构造函数被用来初始化callme2()的形参，还被用来将对象sailor初始化为对象sports。默认的复制构造函数不说明其行为，因此它不指出创建过程，也不增加num_strings的值。但析构函数更新了计数，并且在任何对象过期时都将被调用，而不管对象是如何被创建的。这是一个问题，因为这意味着程序无法准确地记录对象计数。解决办法是提供一个对计数进行更新的显示复制构造函数：
```
StringBad::StringBad(const string &)
{
    num_strings++;
    ...
}
```
**提示：** 如果类中包含这样的静态数据成员，即其值将在新对象被创建时发生变化，则应该提供一个显示复制构造函数来处理计数问题。

第二个异常之处更微妙，也更危险，其症状之一是字符串内容出现乱码：
```
headline2:Du
```
原因在于隐式复制构造函数是按值进行复制的。例如，隐式复制构造函数的功能相当于：
```
sailor.str = sport.str;
```
这里复制的并不是字符串，而是一个指向字符串的指针。也就是说，将sailor初始化为sports后，得到的是两个指向同一个字符串的指针。当operator<<()函数使用指针来显示字符串时，这并不会出现问题。但当析构函数被调用时，这将引发问题。析构函数StringBad释放str指针指向的内存。因此释放sailor的效果如下：
```
delete [] sailor.str;
```
sailor.str指针指向"spinach"，因为它被赋值为sports.str，而sports.str指向的正是上述字符串。所以delete语句将释放字符串"spinach"占用的内存。

然后，释放sports的效果如下：
```
delete [] sports.str;
```
sports.str指向的内存已经被sailor的析构函数释放，这将导致不确定的、可能有害的后果。程序中生成受损的字符串，这通常是内存管理不善的表现。另一个症状是，试图释放内存两次可能导致程序异常终止。

##### 1. 定义一个显示复制构造函数以解决问题
解决类设计中这种问题的方法是进行深度复制。也就是说，复制构造函数应当复制字符串并将副本的地址赋给str成员，而不仅仅是复制字符串地址。这样每个对象都有自己的字符串，而不是引用另一个对象的字符串。调用析构函数时都将释放不同的字符串，而不会试图去释放以及被释放的字符串。

可以这样编写String的复制构造函数：
```
StringBad::StringBad(const StringBad & st)
{
    num_strings++;
    len = new char[len+1];
    std::strcpy(str,st.str);
    cout<<num_strings <<": \ " " << str
        <<"\" object created";
}
```

必须定义复制构造函数的原因在于，一些类成员是使用new初始化的、指向数据的指针，而不是数组本身。

**警告：** 如果类中包含了使用new初始化的指针成员，应当定义一个复制构造函数，以复制指向的数据，而不是指针，这被称为**深度复制**。复制的另一种形式(成员复制或浅复制)只是复制指针值。浅复制仅浅浅地复制指针信息，而不会深入"挖掘"以复制指针引用的结构。

#### 1.4 StringBad的其他问题：赋值运算符

并不是程序中所有的问题都可以归咎于默认的复制构造函数，还需要看一看默认的赋值运算符。ANSI C允许结果赋值，而C++允许类对象赋值，这是通过自动为类重载赋值运算符实现的。这种运算符的原型如下：
```
Class_name & Class_name::operator=(const Class_namw &);
```
它接受并返回一个指向类对象的引用。例如，StringBad类的赋值运算符的原型如下：
```
StringBad & StringBad::operator=(const StringBad &);
```

##### 1. 赋值运算符的功能以及何时使用它
将已有的对象赋给另一个对象时，将使用重载赋值运算符：
```
StringBad headline1("celery");
...
StringBad knot;
knot = headline1;
```
初始化对象时，并一定会使用赋值运算符：
```
StringBad metoo = knot;
```
这里，metoo是一个新创建的对象，被初始化为knot的值，因此使用复制构造函数。然而，正如前面指出的，实现时也可能分两步来处理这条语句：使用复制构造函数创建一个临时对象，然后通过赋值将临时对象的值复制到新对象中。这就是说，初始化总是会调用复制构造函数，而是用=运算符也可能调用赋值运算符。

与复制构造函数相似，赋值运算符的隐式实现也对成员进行逐个复制。如果成员本身就是类对象，则程序将使用为这个类定义的赋值运算符来复制该成员，但静态数据成员不受影响。

##### 2. 赋值的问题出在哪里
```
knot = headline1;
```
为knot调用析构函数时，将显示下面的消息：
```
"celery" object deleted, 2 left
```
为headline1调用析构函数时，将显示下面的消息：
```
"-|" object deleted, -2 left
```
出现的问题与隐式复制构造函数相同：**数据受损**。这也是成员复制的问题，即导致headline1.str和knot.str指向相同的地址。因此，当对knot调用析构函数时，将删除字符串"celery"：当对headline1调用析构函数时，将试图删除前面已经删除的字符串，导致的结果是不确定的，因此可能改变内存中的内容，导致程序异常终止。要指出的是，如果操作结果是不确定的，则执行的操作将随编译器而异，包括显示独立声明或释放隐藏文件占用的硬件空间。当然，编译器开发人员通常不会花时间添加这样的行为。

##### 3. 解决赋值的问题
对由于默认赋值运算符不合适而导致的问题，解决办法是提供赋值运算符(进行深度复制)定义。其实现与复制构造函数相似，但也有一些差别。
- 由于目标对象可能引用了以前分配的数据，所以函数应使用delete[]来释放这些数据。
- 函数应当避免将对象赋给自身；否则，给对象重新赋值前，释放内存操作可能删除对象的内容。
- 函数返回一个指向调用对象的引用。

通过返回一个对象，函数可以像常规函数赋值操作那样，连续进行赋值，即如果S0、S1、S2都是StringBad对象，则可以编写这样的代码：
```
S0=S1+S2;
```
使用函数表示法时，上述代码为：
```
S0.operator=(S1.operator=(S2));
```
因此，S1.operator=(S2)的返回值是S0.operator=()的参数。

下面的代码说明了如何为StringBad类编写赋值运算符：
```
StringBad & StringBad:: operator=(const StringBad & st)
{
    if(this == &st)
        return *this;
    delete [] str;
    len = st.len;
    str=new char[len+1];
    std:strcpy(str,st.str);
    return *this;
}
```

代码首先检查自我复制，这是通过查看赋值运算符右边的地址是否与接受对象(this)的地址相同来完成的。如果相同，程序将返回*this，然后结束。

如果地址不同，函数将释放str指向的内存，这是因为稍后将把一个新字符串的地址赋给str。如果不首先使用delete运算符，则上述字符串将保留在内存中。由于程序中不再包含指向该字符串的指针，因此这些内存被浪费掉。

接下来的操作与复制构造函数相似，即为新字符串分配足够的内存空间，然后将赋值运算符右边的对象中的字符串复制到新的内存单元中。
上述操作完成后，程序返回*this并结束。

赋值操作并不创建新的对象，因此不需要调整静态数据成员num_strings的值。

将前面的复制构造函数和赋值运算符添加到StringBad类中后，所有的问题都解决了。例如，下面是在完成上述修改后，程序输出的最后几行：
```
Exiting the block:
"celery" object deleted, 4 left
"spinach"  object deleted, 3 left
"spinach" object deleted, 2 left
"lettuce" object deleted, 1 left
"celery" object deleted, 0 left
End of main()
```
现在，对象计数是正确的，字符串也没有被损坏。

### 12.2 改进后的新String类

#### 2.1 修订后的默认构造函数
新的默认构造函数，与下面类似：
```
String::String()
{
    len=4;
    str=new char[4];
    str[0]='\0';
    num_strings++'
}
```
你可能会问，为什么代码为：
```
str=new char[1];
```
而不是:
```
sre = new char;
```
上面两种方式分配的内存量相同，区别在于前者与类析构函数兼容，而后者不兼容。析构函数中包含如下代码：
```
delete [] str;
```
delete [] 与使用new []初始化的指针和空指针都兼容。因此对于下述代码;
```
str = new char[1];
str[0] = '\0';
```
可修改为：
```
str = 0 // set str to the null pointer
```
对于以其他方式初始化的指针，使用delete[]时，结果将是不确定的：
```
char words[15] = "bad idea";
char * p1 = words;
char * p2 = new char;
char * p3;
delete [] p1;  // undifined, so don't do it
delete [] p2;  // undifined, so don't do it
delete [] p3;  // undifined, so don't do it
```

##### C++11空指针
在C++98中，字面值0有两个含义：可以表示数字值零，也可以表示空指针，这使得阅读程序的人和编译器难以区分。有些程序员使用(void *)0来标识空指针(空指针本身的内部标识可能不是零)，还有些程序员使用NULL，这是一个表示空指针的C语言宏。C++11提供了更好的解决方案：引入新关键字nullptr，用于表示空指针。您仍可能像以前一样使用0——否则大量现有的代码将非法，但建议您使用nullptr:
```
str = nullptr;
```
#### 2.2 比较成员函数

。。。

#### 2.3 使用中括号表示法访问字符
。。。

#### 2.4 静态类成员函数
。。。
#### 2.5 进一步重载赋值运算符
。。。

```
class String
{
    private:
        char * str;
        int len;
        static int num_strings;
        static const ubt CINLIM = 80; // cin input limit
    public:
    // constructors and other methods
        String();
        String(const chaar * s);
        String(const String &);
        ~String();
     // overloaded operator methods
        String & operator = (cosnt char *);
        String & operator = (cosnt String &);   
        ...
};
#endif
```

方法定义：
```
String::String()
{
    len=4;
    str=new char[4];
    str[0]='\0';
    num_strings++'
}

StringBad::StringBad(const char * s)
{
   
    len = std::strlen(s);
    str = new char[len+1];
    std::strcpy(str,s);
    num_strings++;
}


StringBad::StringBad(const StringBad & st)
{
    num_strings++;
    len = new char[len+1];
    std::strcpy(str,st.str);
}

String::~String()
{
    --num_strings;
    delete [] str;
}

StringBad & StringBad:: operator=(const StringBad & st)
{
    if(this == &st)
        return *this;
    delete [] str;
    len = st.len;
    str=new char[len+1];
    std:strcpy(str,st.str);
    return *this;
}


StringBad & StringBad:: operator=(const char * s)
{
    delete [] str;
    len = std::strlen(s);
    str=new char[len+1];
    std:strcpy(str,s);
    return *this;
}

...
```

### 12.3 在构造函数中使用new时应注意的事项

- 如果
- new和delete
- 应定义一个复制构造函数，通过深度复制一个对象初始化为另一个对象。通常，这种构造函数与下面类似。
```
String::String(const String & st)
{
    num_strings++;
    len=st.len;
    str=new char[len+1];
    std::strcpy(str,st.str);
}
```
具体来说，复制构造函数应分配足够的空间来存储复制的数据，并复制数据，而不仅仅是数据的地址。另外，还应该更新所有受影响的静态类成员。

- 应当定义一个赋值运算符，通常深度赋值将一个对象复制给另一个对象。通常，该类方法与下面类似：
```
String & String::operator=(const String & st)
{
    if(this==&st)
        return * this;
    delete [] str;
    len=st.len;
    str = new char [len+1];
    std::strcpy(str,st.str);
    return * this;
}
```
具体来说，该方法应完成这些操作：检查自我赋值的情况，释放成员指针以前指向的内存，复制数据而不仅仅是数据的地址，并返回一个指向调用对象的引用。

#### 3.1 应该不应该


#### 3.2 包含类成员的类的逐成员复制




### 12.4 有关返回对象的说明



#### 4.1 返回指向const对象的引用

#### 4.2 返回指向非const对象的引用

#### 4.3 返回对象

#### 4.4 返回const对象






### 12.5 使用指向对象的指针
。。。

### 12.6 复习各种技术

#### 6.1 重载<<运算符
要重新定义<<运算符，以便将它和cout一起用来显示对象的内容，请定义下面的友元运算符函数：
```
ostream & operator(ostream & os, const c_name & obj)
{
    os << ...;    //display object contents
    return os;
}
```

其中，c_name是类名。如果该类提供了能够返回所需内容的公有方法，则可在运算符函数中使用这些方法，这样便不用将它们设置为友元函数了。


#### 6.2 转换函数
要将单个值转换为类类型，需要创建原型如下所示的类构造函数；
    ```
    c_name(type_name value);
    ```
要将类转换为其他类型，需要创建原型如下所示的类成员函数：
    ```
    operator type_name();
    ```
虽然该函数没有声明返回类型，但应返回所需类型的值。
使用转换函数时要小心，可以在声明构造函数时使用关键字explicit，以防止它被用于隐式转换。

#### 6.3 其构造函数使用new的类
如果类使用new运算符来分配类成员指向的内存，在设计时应采取一些预防措施。
- 对于指向的内存是由new分配的所有类成员，都应在类的析构函数中对其使用delee，该运算符将释放分配的内存。
- 如果析构函数通过对指针类成员使用delete来释放内存，则每个构造函数都应当使用new来初始化指针，或将它设置为空指针。
- 构造函数中要么使用new\[]，要么使用new，而不能混用。如果构造函数使用的是new\[]，则析构函数应使用delete[]；如果构造函数使用的是new，则析构函数应使用delete。
- 应定义一个分配内存(而不是将指针指向已有内存)的复制构造函数。这样程序将能够将类对象初始化为另一个类对象。这种构造函数的原型通常如下：
    ```
    className(const className &)
    ```
- 应定义一个重载赋值运算符的类成员函数，其函数定义如下(其中c_pointer是c_name的类成员，类型为指向type_name的指针)。下面的示例假设使用new[]来初始化变量c_pointer:
    ```
    c_name & c_name::operator=(const c_name & cn)
    {
        if(this == & cn)
            return *this;
        delete [] c_pointer;
        c_pointer = new type_name[size];
        ...
        return *this;
    }
    ```

