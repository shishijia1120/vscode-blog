## 7 函数——C++的编程模块
C++自带了一个包含函数的大型库(标准ANSI库加上多个C++类)，但真正的编程乐趣在于编写自己的函数。

### 7.1 函数的基本知识
要使用C++函数，必须完成如下工作：
- 提供函数定义；
- 提供函数原型；
- 调用函数。

#### 1. 定义函数
定义函数的通用格式：
```
typeName functionName(parameterList)
{
    statements
    return value;
}
```
C++对于返回值的类型有一定的限制：不能是数组，但可以是其他任何类型——整数、浮点数、指针、结果和对象。

通常，函数通过将返回值复制到指定的CPU寄存器或内存单元中来将其返回。随后，调用程序将查看该内存单元。返回函数和调用函数必须就该内存单元中存储的数据的类型达成一致。

#### 2. 函数原型和函数调用

**2.1 为什么需要原型**
原型描述了函数到编译器的接口，也就是说，它将函数返回值的类型以及参数的类型和数量告诉编译器。例如：
    ```
    double volume = cube(side);
    ```
首先，原型告诉编译器，cube()有一个double参数。如果程序没有提供这样的参数，原型将让编译器能够捕获这种错误。其次，cube()函数完成计算后，将把返回值放置在指定的位置——可能是CPU寄存器，也可能是内存中。然后调用函数(这里为main())将从这个位置取得返回值。由于原型指出了cube()的类型为double，因此编译器知道应检索多少个字节以及如何解释它们。如果没有这些信息，编译器将只能进行猜测，而编译器是不会这样做的。

为何编译器需要原型？为什么不能在文件中进一步查找，以了解函数是如何定义的吗？这种方法的一个问题是效率不高，编译器在搜索文件的剩余部分时将必须停止对main()的编译。一个更严重的问题是，函数甚至可能并不在文件中。或者无权访问某些函数代码。

避免使用函数原型的唯一方法是，在首次使用函数定义之前访问它，但这并不总是可行的。另外，C++的编程风格是将main()放在最前面，因为它通常提供了程序的整体结构。


**2.2 原型的语法**
函数原型是一条语句，因此必须以分号结束。获得原型最简单的方法是，复制函数定义的函数头，并添加分号。然而，函数原型不要求提供变量名，有类型列表就足够了。

**2.3 原型的功能**
。。。



### 7.2 函数参数和按值传递
C++通常按值传递参数，这意味着将数值参数传递给函数，而后者将其赋给一个新的变量。

#### 1. 多个参数
。。。

#### 2. 另外一个接受两个参数的函数
。。。

### 7.3 函数和数组
将数组作为函数的参数，需要将一个形参声明为数组名。例如：
```
int sum_arr(int arr[],int n) // arr=array name , n=size
```
实际上，arr并不是数组，而是一个指针！但在编写函数的其余部分时，可以将arr看作是数组。

#### 1. 函数如何使用指针来处理数组
在大多数情况下，C++和C语言一样，也将数组名视为指针。
    ```
    int sum= sum_arr(cookies,ArSize);
    ```
其中，cookies是数组名，而根据C++规则，cookies是其第一个元素的地址，因此函数传递的是地址。由于数组的元素的类型为int，因此cookies的类型必须是int指针，即int *。这表明，，正确的函数头应该是这样的：
    ```
    int sum_arr(int * arr, int n)
    ```
其中用int * arr替换了int arr[]。这证明这两个函数头都是正确的，因为在C++中，当(且仅当)用于函数头或函数原型中，int* arr和int arr[]的含义才是相同的。它们都意味着arr是一个int指针。
在其他的上下文中，int*arr和int arr[]的含义并不相同。

**两个恒等式**：
```
arr[i] == *(arr+i)
&arr[i] == arr+i
```
#### 2. 将数组作为参数意味着什么
传递常规变量时，函数将使用该变量的拷贝；但传递数组时，函数将使用原来的数组。实际上，这种区别并不违反C++按值传递的方法，sum_arr()函数仍传递了一个值，这个值被赋给一个新变量，但这个值是一个地址，而不是数组的内容。

将数组地址作为参数可以节省复制整个数组所需的时间和内存。另一方面，使用原始数据增加了破坏数据的风险，可使用const限定符来避免这个问题。
。。。

#### 3. 更多数组函数示例
。。。


#### 4. 使用数组区间的函数
。。。


### 7.4 函数和二维数组
。。。


### 7.5 函数和C-风格字符串
C-风格字符串由一系列字符组成，以空值字符结尾。将字符串作为参数时意味着传递的是地址，但可以使用const来禁止对字符串参数进行修改。

#### 1. 将C-风格字符串作为参数的函数
假设要将字符串作为参数传递给函数，则表示字符串的方式有三种：
- char数组；
- 用引号括起的字符串常量(也称字符串字面值)；
- 被设置为字符串的地址的char指针。

但上述3种选择的类型都是char指针(准确地说是char *)，因此可以将其作为字符串处理函数的参数。

可以说将字符串作为参数来传递，但实际传递的是字符串第一个字符的地址，这意味着字符串函数原型应将其表示为字符串的形参声明为char*类型。

C-风格字符串与常规char数组之间的一个重要区别是，字符串有内置的结束字符。这意味着不必将字符串长度作为参数传递给函数，而函数可以使用循环依次检查字符串中的每个字符，直到遇到结尾的空值字符为止。
```

unsigned int c_in_str(const char * str,char n)
{
    unsigned int count=0;

    while(*str)
    {
        if(*str == ch)
            cout++;
        str++;
    }
    return count;
}
```
#### 2. 返回C-风格字符串的函数
函数无法返回一个字符串，但可以返回字符串的地址，这样做的效率更高。

#### 7.6 函数和结构
为结构编写函数比为数组编写函数要简单得多。使用结构编程时，最直接得方式是像处理基本类型那样来处理结构；也就是说，将结构作为参数传递，并在需要时将结构用作返回值使用。然而，如果结构非常大，则复制结构将增加内存需求。因此，许多C程序员倾向于传递结构得地址，然后使用指针来访问结构得内容。C++提供了第三种选择——按引用传递。

下面介绍其他两种传递方式：
#### 1. 传递和返回结构
当结构比较小时，按值传递结构最合理。

#### 2. 传递结构的地址
假设要传递结构的地址而不是整个结构以节省时间和空间，则需要重新编写前面的函数，使用指向结构的指针。
- 将形参声明为指针，如果函数不应该修改结构，需使用const修饰符；
- 由于形参是指针而不是结构，应使用->而不是.;
- 调用函数时，将结构的地址(&place)而不是结构本身(place)传递给它。

### 7.7 函数和string对象
虽然C-风格字符串和string对象的用途几乎相同，但与数组相比，string对象与结构的更相似，string可以赋值。

### 7.8 函数与array对象



### 7.9 递归

### 7.10 函数指针

----
## 8 函数探幽
C++还提供许多新的函数特性。使之有别于C语言。新特性包括内联函数、按引用传递变量、默认的参数值、函数重载(多态)以及模板函数。

### 8.1 C++内联函数
内联函数是C++为提高程序运行速度所做的一项改进。常规函数和内联函数之间的主要区别不在于编写方式，而在于C++编译器如何将它们组合到程序中。要了解内联函数与常规函数之间的区别，必须深入到程序内部。

编译过程的最终产品是可执行程序——由一组机器语言指令组成。运行程序时，操作相同将这些指令载入到计算机内存中，因此每条指令都有特定特定的内存地址。计算机随后将逐步执行这=这些指令。有时(如有循环或分支语句时)，将跳过一些指令，向前或向后跳到特定地址。常规变量调用也使程序跳到另一个地址(函数的地址)，并在函数结束时返回。
下面将详细地介绍这一过程的典型实现。执行到函数调用指令时，程序将在函数调用后立即存储该指令的内存地址，并将函数参数复制到堆栈(为此保留的内存块)，跳到标记函数起点的内存单元，执行函数代码(也许还需将返回值放入到寄存器中)，然后跳回到地址被保存的指令处(这与阅读文章时停下来看脚注，并在阅读完脚注后返回到以前阅读的地方类似)。来回跳跃并记录跳跃位置意味着以前使用函数时，需要一定的开销。

C++内联函数提供了另一种选择。编译器将使用相应的函数代码替换函数调用。对于内联代码，程序无需跳到另一个位置处执行代码，再跳回来。因此，内联函数的运行速度比常规函数稍快，但代价是需要更多内存。如果程序在10个不同的地方调用同一个内联函数，则该程序将包含该函数的10个副本。

应有选择地使用内联函数。如果执行函数代码的时间比处理函数调用机制的时间长，则节省的时间将只占整个过程的很小一部分。如果代码执行时间很短，则内联调用就可以节省非内联调用使用的大部分时间。另一方面，由于这个过程相当快，因此尽管节省了该过程的大部分时间，但节省的时间绝对值并不大，除非该函数经常被调用。


要使用这项特性，必须采取下述措施之一：
- 在函数声明前加上关键字inline;
- 在函数定义前加上关键字inline。

### 8.2 引用变量
C++新增了一种复合类型——引用变量。引用是已定义的变量的别名(另一个名称)。但引用变量的主要作用是用作函数的形参。通过将引用变量用作参数，函数将使用原始数据，而不是其副本。这样除指针之外，引用也为函数处理大型结构提供了一种非常方便的途径，同时对于设计类来说，引用也是必不可少的。

#### 1. 创建引用变量
C++给&符号赋予了另一个含义，将其用来声明引用。
```
int rats;
int & rodents =rats;
```
int &指的是指向int的引用。上述引用声明允许将rats和rodents互换——它们指向相同的值和内存单元。

**注意：** 必须在声明引用变量时进行初始化。
引用更接近const指针，必须在创建时进行初始化，一旦与某个变量关联起来，就将一直效忠于它。也就是说：
    ```
    int & rodents =rats;
    ```
实际上是下述代码的伪装表示：
    ```
    int * const pr = &rats;
    ```
其中，引用rodents扮演的角色与表达式*pr相同。


```
int rats = 101;
int & rodents = rats;


int bunnies =50;
rodents=bunnies;


```

最初，rodents引用的是rats，但随后程序试图将rodents作为bunnies的引用：
    ```
    rodents=bunnies;
    ```
乍一看，这种意图暂时是成功的，因为rodents的值从101变为了50。但仔细研究发现，rats也变成了50，同时rats和rodents的地址相同，而该地址与bunnies的地址不同。由于rodents是rats的别名，因此上述赋值语句与下面的语句等效：
    ```
    rats=bunnies;
    ```
也就是说，这意味着"将bunnies变量的值赋给rat变量"。简而言之，可以通过初始化声明来设置引用，但不能通过赋值来设置。

假设程序员试图这样做：
```
int rats =101;
int * pt = &rats;
int & rodents = *pt;
int bunnies =50;
pt=&bunnies;
```
将rodents初始化为*pt使得rodents指向rats。接下来将pt改为指向bunnies，并不能改变这样的事实，即rodetns引用的是rats。

#### 2. 将引用用作函数参数
引用经常被用作函数参数，使得函数中的变量名成为调用程序中的变量的别名。这种传递参数的方法称为按引用传递。按引用传递允许被调用的函数能够访问调用函数中的变量。C++新增的这项特性是对C语言的超越，C语言只能按值传递，当然，C语言也允许避开按值传递的限制，采用按指针传递的方式。
    ```
    void swappr(int & a,int &b)
    ```
前面说过，应在定义引用变量时对其进行初始化，函数调用使用实参初始化形参，因此函数的引用参数初始化为函数调用传递的实参。也就是说，下面的函数调用将形参a和b分别初始化为wallet1和wallet2:
    ```
    swapr(wallet1,wallet2);
    ```
#### 3. 引用的属性和特别之处
引用参数的函数的限制更严格，一般而言实参应该是变量。

##### 临时变量、引用变量参数和const
如果实参与引用参数不匹配，C++将生成临时变量。当前，仅当参数为const引用时，C++才允许这样做，但以前不是这样。

首先，什么时候将创建临时变量呢？如果引用参数是const，则编译器将在下面两种情况下生成临时变量：
- 实参的类型正确，但不是左值；
- 实参的类型不正确，但可以转换为正确的类型。

左值参数是可被引用的数据对象，如变量、数组元素、结构成员、引用和解除引用的指针都是左值。非左值包括字面常量(用引号括起的字符串除外，它们由其地址表示)和包含多项的表达式。。。。


```
double refcube(const double &ra)
{
    return ra * ra * ra;
}
```
现在考虑下面的代码：
```
double side =3.0;
double * pd=&side;
double & rd=side;
long edge =5L;
double lens[4]={2.0,5.0,10.0,12.0};

double c1=refcube(side);
double c2=refcube(lens[2]);
double c3=refcube(rd);
double c4=refcube(*pd);
double c5=refcube(edge);
double c6=refcube(7.0);
double c7=refcube(side+10.0);

```
参数side、len[2]、rd和*pd都是有名称的double类型的数据对象，因此可以为其创建引用，而不需要临时变量(还记得吗，数组元素的行为与同类型的变量类似)。然而，edge虽然是变量，类型却不正确，double引用不能指向long。另一方面，参数7.0和side+10.0的类型都正确，但没有名称，在这种情况下，编译器都将生成一个临时匿名变量，并让ra指向它。这些临时变量只在函数调研期间存在，此后编译器便可以随意将其删除。

那么为什么对于常量引用，这种行为是可行的，其他情况下却不行的呢？
```
void swapr(int & a,int & b)
{
    int temp;

    temp=a;
    a=b;
    b=temp;
}
```
如果在早期C++较宽松的规则下，执行下面的操作将发生什么情况呢？
```
long a=3,b=5;
swapr(a,b);
```
这里的类型不匹配，因此编译器将创建两个临时int变量，将它们初始化为3和5，然后交换临时变量的内容，而a和b保持不变。

简而言之，如果接受引用参数的函数的意图是修改作为参数传递的变量，则创建临时变量将阻止这种意图的实现。解决方法是，禁止创建临时变量，现在的C++标准正是这样做的(然而，在默认情况下，有些编译器仍将发出警告，而不是错误消息，因此如果看到了有关临时变量的警告，请不要忽略)。

现在来看refcube()函数。该函数的目的只是使用传递的值，而不是修改它们，因此临时变量不会造成任何不利的影响，反而会使函数在可处理的参数种类方面更通用。因此，如果声明将引用指定为const，C++将在必要时生成临时变量。实际上，对于形参为const引用的C++函数，如果实参不匹配，则其行为类似于按值传递，为确保原始数据不被修改，将使用临时变量来存储值。

**注意：** 如果函数调用的参数不是左值或与相应的const引用参数的类型不匹配，则C++将创建类型正确的匿名变量，将函数调用的参数的值传递给该匿名变量，并让参数来引用该变量。

##### 应尽可能使用const：
将引用参数声明为常量数据的引用的理由有三个：
- 使用const可以避免无意中修改数据的编程错误；
- 使用const使函数能够处理const和非const实参，否则将只能接受非const数据；
- 使用const引用使函数能够正确生成并使用临时变量。

因此，应尽可能将引用形参声明为const。


**右值引用**
。。。

#### 4. 将引用用于结构
引用非常适合用于结构和类(C++的用户定义类型)。确实，引入引用主要是为了用于这些类型的，而不是基本的内置类型。



##### 4.1 
。。。

##### 4.2 为何要返回引用

传统返回机制与按值传递函数参数类似：计算关键字return后面的表达式，并将结果返回给调用函数。从概念上说，这个值被复制到一个临时变量，而调用程序将使用这个值。请看下面的代码：
```
double m=sqrt(16.0);
cout << sqrt(25.0);
```
在第一条语句中，值4.0被复制到一个临时位置，然后被复制给m。在第二条语句中，值5.0被复制到一个临时位置，然后被传递给cout(这里理论上的描述，实际上，编译器可能合并某些步骤)。

现在来看下面的语句：
```
dup=accumulate(team,five);
```
如果accumulate()返回一个结构，而不是指向结构的引用，将把整个结构复制到一个临时位置，再将这个拷贝赋值给dup。但在返回值为引用时，将直接把team复制到dup，其效率更高。

**注意：** 返回引用的函数实际上是被引用的变量的别名。


##### 4.3 返回引用时需要注意的问题
返回引用时最重要的一点是，应避免返回函数终止时不再存在的内存单元引用。应避免编写下面这样的代码：
```
const free_throws & clone2(free_throws & ft)
{
    free_throws newguy;
    newguy=ft;
    return newguy;
}
```
该函数返回一个指向临时变量(newguy)的引用，函数运行完毕后它将不再存在。同样，也应避免返回指向临时变量的指针。

为避免这种问题，最简单的方法是，返回一个作为参数传递给函数的引用。作为参数的引用将指向调用函数使用的数据，因此返回的引用也将指向这些数据。
另一种方法是用new来分配新的存储空间。前的见过这样的函数，它使用new为字符串分配内存空间，并返回指向该内存空间的指针。
```
const free_throws & clone (free_throws & ft)
{
    free_throws * pt;
    *pt=ft;
    return *pt;
}
```
第一条语句创建一个无名的free_throws结构，并让指针pt指向该结构。因此*pt就是该结构。上述代码似乎会返回该结构，但函数声明表明，该函数实际上将返回这个结构的引用。这样，便可以这样使用该函数：
```
free_throws & jolly = clone(three);
```
这使得jolly成为新结构的引用。这种方法存在一个问题：在不再需要new分配的内存时，应使用delete来释放它们。调用clone()隐藏了对new的调用，这使得以后很容易忘记使用delete来释放内存。

##### 4.4 为何将const用于引用返回类型
。。。






#### 5. 将引用用于类对象
将类对象传递给函数时，C++通常的做法是使用引用。例如，让函数将类string、ostream、istream、ofstream和ifstream等类的对象作为参数。

如果形参类型为const string &，在调用函数时，使用的实参可以是string对象或C-风格字符串，如用引号括起的字符串面量、以空字符结尾的char数组或指向char的指针变量。

首先，string类定义了一种char *到string的转换功能，这使得可以使用C-风格字符串来初始化string对象。其次是本章前面讨论过的类型为const引用的形参的一个属性。假设实参的类型与引用参数类型不匹配，但可被转换为引用类型，程序将创建一个正确类型的临时变量，使用转换后的实参值来初始化它，然后传递一个指向该临时变量的引用。
#### 6. 对象、继承和引用
ostream和ofstream类凸显了引用的一个有趣属性。ostream是基类(因为ofstream是建立在它的基础之上的)，而ofstream是派生类(因为它是从ostream派生而来的)。派生类继承了基类的方法，这意味着ofstream对象可以使用基类的特性，如格式化方法precision()和setf()。

继承的另一个特征是，基类引用可以指向派生类对象，而无需进行类型转换。这种特征的一个实际结果是，可以定义一个接受基类引用作为参数的函数，调用该函数时，可以将基类对象作为参数，也可以将派生类对象作为参数。
例如，参数类型为ostream&的函数可以接受ostream对象(如cout)或您声明的ofstream对象作为参数。

#### 7. 何时使用引用参数
使用引用参数的主要原因有两个。
- 程序员能够修改调用函数中的数据对象。
- 通过传递引用而不是整个数据对象，可以提高程序的运行速度。

引用参数实际上是基于指针的代码的另一个接口。
##### 何时使用引用、何时使用指针、何时按值传递：

**a. 对于使用传递的值而不作修改的函数:**
- 如果数据对象很小，如内置数据类型或小型结构，则按值传递。
- 如果数据对象是数组，则使用指针，因为这是唯一的选择，并将指针声明为指向const的指针。
- 如果数据对象是较大的结构，则使用const指针或const引用，以提高程序的效率。这样可节省复制结构所需的时间和空间。
- 如果数据对象是类对象，则使用const引用。类设计的语义常常要求使用引用，这是C++新增这项特性的主要原因。因此，传递类对象参数的标准方式是按引用传递。

**b. 对于修改调用函数中数据的函数**
- 如果数据对象是内置数据类型，则使用指针。如果看到诸如fixit(&x)这样的代码(其中x是int)，则很明显，该函数将修改x。
- 如果数据对象是数组，则只能使用指针。
- 如果数据对象是结构，则使用引用或指针。
- 如果数据对象是类对象，则使用引用。

当然，这只是一些指导原则，很可能有充分的理由做出其他的选择。例如，对于基本类型，cin使用引用，因此可以使用cin>>n，而不是cin>>&n。

### 8.3 默认参数

### 8.4 函数多态