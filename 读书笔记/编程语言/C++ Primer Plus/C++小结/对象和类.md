## 10 对象和类
面向对象编程(OOP)是一种特殊的、设计程序的概念性方法，C++通过一些特性改进了C语言，使得应用这种方法更容易。下面是最重要的OOP特性：
- 抽象；
- 封装和数据隐藏；
- 多态；
- 继承；
- 代码的可重用性。

### 10.1 过程性编程和面向对象编程
接口描述了用户如何初始化、更新和显示数据。抽象是通往用户定义类型的捷径，在C++中，用户定义类型指的是实现抽象接口的类设计。

### 10.2 抽象和类
接口描述了用户如何初始化、更新和显示数据。抽象是通往用户定义类型的捷径，在C++中，用户定义类型指的是实现抽象接口的类设计。
#### 1. 类型是什么



#### 2. C++中的类
类是一种将抽象转换为用户定义类型的C++工具，它将数据表示和操纵数据的方法组合成一个整洁的包。

##### 什么是接口
接口是一个共享框架，供两个系统(如在计算机和打印机之间或者用户或计算机程序之间)交互时使用；例如，用户可能是您，而程序可能是字处理器。使用字处理器时，您不能直接将脑子中想到的词传输到计算机内存中，而必须同程序提供的接口交互。

对于类，我们说公共接口。在这里，公众(public)是使用类的程序，交互系统由类对象组成，而接口由编写类的人提供的方法组成。接口让程序员能够编写与类对象交互的代码，从而让程序能够使用类对象。

例如，要计算string对象中包含多少个字符，你无需打开对象，而只需要使用string类提供的size()方法。类设计禁止公共用户直接访问类，但公众可以使用方法size()。方法size()是用户和string类对象之间的公共接口的组成部分。通常，方法getline()是istream类的公共接口的组成部分，使用cin的程序不是直接与cin对象内部交互来读取一行输入，而是使用getline()。

如果希望更人性化，不要将使用类的程序视为公共用户，而将编写程序的人视为公共用户。然而，要使用某个类，必须了解其公共接口；要编写类，必须创建其公共接口。

通常，C++程序员将接口(类定义)放在头文件中，并将实现(类方法的代码)放在源代码文件中。

```
class Stock
{
    private:
        long shares;
        double share_val;
        double total_val;
        void set_tot(){total_val=shares * share_val;}

    public:
        void acquire();
        void show();
        ...
};

```

###### a. 访问控制
关键字private和public也是新的，它们描述了对类成员的访问控制。使用类对象的程序可以直接访问公有部分，但只能通过公有成员函数(或友元函数)来访问对象的私有成员。公有成员函数是程序和对象私有成员之间的桥梁，提供了对象和程序之间的接口。防止程序直接访问数据被称为数据隐藏。C++提供了第三个访问控制关键字protecetd。

类设计尽可能将共有接口与实现细节分开。共有接口表示设计的抽象组件。将实现细节放在一起并将它们与抽象分开被称为封装。数据隐藏(将数据放在类的私有部分)是一种封装，将实现的细节隐藏在私有部分中，就像Stock类对set_tot()所做的那样，也是一种封装。封装的另一个例子是，将类函数定义和类声明放在不同的文件中。

##### OOP和C++
C++中包括了许多专门用来实现OOP方法的特性，因此它使程序员更进一步。首先，将数据表示和函数原型放在一个类声明(而不是放在一个文件中)，通过将所有内容放在一个类声明中，来使描述成为一个整体。其次，让数据表示成为私有，使得数据只能被授权的函数访问。

###### b. 控制对成员的访问：公有还是私有
无论类成员是数据成员还是成员函数，都可以在类的共有部分或私有部分中声明它。但由于隐藏数据是OOP主要的目标之一，因此数据项通常放在私有部分，组成类接口的成员函数放在公有部分；否则，就无法从程序中调用这些函数。通常，程序员使用私有成员函数来处理不属于公有接口的实现细节。

###### 类和结构：
类描述看上去很像是包含成员函数以及public和private可见性标签的结构声明。实际上，C++对结构进行了扩展，使之具有与类相同的特性。它们之间唯一的区别是，结构的默认访问类型是public。而类位private。C++程序员通常使用类来实现类描述，而把结构限制只表示为纯粹的数据对象(普通老式数据)。

#### 3. 实现成员函数
还需要创建类描述的第二部分：为那些由类声明中的原型表示的成员函数提供代码。成员函数定义与常规函数定义非常相似，它们有函数头和函数体，也可以有返回类型和参数。但是成员函数有两个特殊的特征：
- 定义成员函数时，使用作用域解析运算符(::)来标识函数所属的类；
- 类方法可以访问类的private组件。



##### 3.1 成员函数说明


##### 3.2 内联方法
其定义位于类声明中的函数都将自动成为内联函数，因此Stock::set_tot()是一个内联函数。类声明常将短小的成员函数作为内联函数，set_tot()符合这样的要求。

如果愿意，也可以在类声明之外定义成员函数，并使其成为内联函数。为此，只需在类实现部分中定义函数时使用inline限定符即可：
```
class Stock
{
    private:
        ...
        void set_tot(); //definition kept separate

    public:
        ...
};

inline void Stock::set_tot()
{
    total_val=shares * share_val;
}
```
内联函数的特殊规则要求在每个使用它们的文件中都对其进行定义。确保内联定义对多文件程序中的所有文件都可用的、最简便的方法是，将内联定义放在类的头文件中(有些开发系统包含智能链接程序，允许将内联定义放在一个独立的实现文件)。

顺便说一句，根据改写规则，在类声明中定义方法等同于用原型替换方法定义，然后在类声明的后面将定义改写为内联函数。也就是说，set_tot()的内联定义与上述代码(定义紧跟在类声明之后)是等价的。

##### 3.3 方法使用哪个对象
创建的每个新对象都有自己的存储空间，用于存储其内部变量和类成员；但同一个类的所有对象共享一组类方法，即每个方法只有一个副本。

例如，假设kata和joe都是Stock对象，则Kate.shares将占据一个内存块，而joe.shares占用另一个内存块，但kate.show()和joe.show()都调用同一个方法，也就是说，它们将执行同一个代码块，只是将这些代码用于不同的数据。在OOP中，调用成员函数被称为发送消息，因此将同样的消息发送给两个不同的对象将调用同一个方法，但该方法被用于两个不同的对象。
#### 4. 使用类
C++的目标是使得使用类与使用基本的内置类型尽可能相同。要创建类对象，可以声明类对象，也可以使用new为类对象分配存储空间。可以将对象作为函数的参数和返回值，也可以将一个对象赋给另一个。

#### 5. 小结
指定类设计的第一步是提供类声明。
```
class className
{
    private:
        data member declarations
    public:
        member function prototypes
};
```
公有部分的内容构成了设计的抽象部分——公有接口。将数据封装到私有部分中可以保护数据的完整性，这被成为数据隐藏。因此，C++通过类使得实现抽象、数据隐藏和封装等OOP特性很容易。

指定类设计的第二步是实现类成员函数。可以在类声明中提供完整的函数定义，而不是函数原型，但是通常的做法是单独提供函数定义(除非函数很小)。在这种情况下，需要使用作用域解析运算符来指出成员函数属于哪个类。
### 10.3 类的构造函数和析构函数
C++目标之一是让使用类对象就像使用标准类型一样，然而，目前为止，还不能像初始化int或结构那样来初始化Stock对象。也就是说，常规的初始化语法不适用于类型Stock:
```
int year = 2001;    // valid
struct thing
{
    char * pn;
    int m;
};

thing amabob ={"wodget",-23};  // valid
Stock hot ={"Sukie",200,50.25}; // compile error!

```
不能像上面那样初始化Stock对象的原因在于，数据部分的访问状态是私有的，这意味着程序不能直接访问数据成员。只能通过成员函数来访问数据成员，因此需要设计合适的成员函数，才能成功地将对象初始化(如果使数据成员成为公有，而不是私有，就可以按刚才的方法初始化类对象，但这样会违背了类的一个主要初衷：数据隐藏)。

一般来说，最好是在创建对象时对它进行初始化。例如：
```
Stock gift;
gift.buy(10,24.75);
```

避免这种问题的方法之一是在创建对象时，自动对它进行初始化。为此，C++提供了一个特殊的成员函数——类构造函数，专门用于构造新对象、将值赋给它们的数据成员。更准确地说，C++为这些成员函数提供了名称和使用语法，而程序员需要提供方法定义。名称与类名相同。构造函数没有返回值，但没有声明为void类型。实际上，构造函数没有声明类型。


#### 1. 声明和定义构造函数
注意，构造函数没有返回类型。构造函数原型位于类声明的公有部分。
```
Stock::Stock(const string & co,long n,double pr)
{
    ...
}
```
上述代码和前面的acquire()相同。区别在于，程序声明对象时，将自动调用构造函数。


##### 成员名和参数名
。。。


#### 2. 使用构造函数
C++提供了两种使用构造函数来初始化对象的方式，第一种方式是显示地调用构造函数：
```
Stock food = Stock("david",250,1.25);
```
另一种方式是隐式地调用构造函数：
```
Stock garment("Furry",50,2.5);
```
每次创建类对象(甚至使用new动态分配内存)时，C++都使用类构造函数。下面是将构造函数与new一起使用的方法：
    ```
    Stock *pstock = new Stock("apple",18,19.0);
    ```
这条语句创建一个Stock对象，将其初始化为参数提供的值，并将该对象的地址赋给pstock指针。在这种情况下，对象没有名称，但可以使用指针来管理对象。

#### 3. 默认构造函数
默认构造函数是在未提供显示初始值时，用来创建对象的构造函数。也就是说，它是用于下面这种声明的构造函数：
    ```
    Stock fluffy_the_cat; // uses the default constructor
    ```
这条语句管用的原因在于，如果没有提供任何构造函数，则C++将自动提供默认构造函数。它是默认构造函数的隐式版本，不做任何工作。对于Stock类来说，默认构造函数可能如下：
    ```
    Stock::Stock(){}
    ```
因此将创建fluffy_the_cat对象，但不初始化其成员，类似于下面的语句创建x，但没有提供值给它一样：
    ```
    int x;
    ```

奇怪的是，当且仅当没有定义任何构造函数时，编译器才会提高默认构造函数。为类定义了构造函数后，程序员就必须为它提供默认构造函数。如果提供了非默认构造函数，但没有提供默认构造函数，则下面的声明将出错：
    ```
    Stock stock1; // not possible with current constructor
    ```
这样做的原因可能是想禁止创建未初始化的对象。然而，如果要创建对象，而不显示地初始化，则必须定义一个不接受任何参数的默认构造函数。定义默认构造函数的方式有两种。一种是给已有构造函数的所有参数提供默认值：
```
Stock(const string & co="Error",int n=0,double pr=0.0);
```
另一种方式是通过函数重载来定义另一个构造函数——一个没有参数的构造函数：
```
Stock();
```
由于只能有一个默认构造函数，因此不要同时采用这两种方式。实际上，通常应初始化所有的对象，以确保所有成员一开始就有已知的合理值。因此，用户定义的默认构造函数通常给所有成员提供隐式初始值。例如：
```
Stock::Stock()
{
    company ="no name";
    shares=0;
    share_val=0.0;
    total_val=0.0;

}
```
**提示：** 在设计类时，通常应提供对所有类成员函数做隐式初始化的默认构造函数。

创建了默认构造函数后，便可以声明对象变量，而不对它们进行显示初始化：
```
Stock first;
Stock first=Stock();
Stock *prelief = new Stock;
```
然而，不要被非默认构造函数的隐式形式所误导：
```
Stock first("abc");
Stock second();
Stock third;
```
第一个声明调用非默认构造函数，即接受参数的构造函数；第二个声明指出，second()是一个返回Stock对象的函数；第三个声明隐式调用默认构造函数。


#### 4. 析构函数
如果构造函数使用new来分配内存，则析构函数将使用delete来释放这些内存。Stock的构造函数没有使用new，因此析构函数实际上没有需要完成的任务。在这种情况下，只需让编译器生成一个什么要不做的隐式析构函数即可。
析构函数在类名前加~，它没有返回值和声明类型。与构造函数不同的是，析构函数没有参数，因此析构函数的原型是这样的：
```
~Stock();
```
由于Stock的析构函数不承担任何重要的工作，因此可这样编写：
```
Stock::~Stock()
{

}
```

##### 不同情况下的析构函数
通常不应在代码中显示调用析构函数(有关例外情形，请看第12章再探定位new运算符)。
- 如果创建的是静态存储类对象，则其析构函数将在程序结束时自动被调用。
- 如果创建的是自动存储类对象，则其析构函数将在程序执行完代码块时(该对象是在其中定义的)自动被调用。
- 如果对象是通过new创建的，则它将驻留在栈内存或自由存储区中，当使用delete来释放内存时，其析构函数将自动被调用。

最后，程序可以创建临时对象来完成特定的操作，在这种情况下，程序将在结束时该对象的使用时自动调用其析构函数。

由于在类对象过期时析构函数将自动被调用，因此必须有一个析构函数。如果程序员没有提供析构函数，编译器将隐式地声明一个默认析构函数，并在发现导致对象被删除的代码后，提供默认析构函数的定义。

#### 5. 构造函数和析构函数小结
通常，构造函数用来初始化类对象的成员，初始化应与构造函数的参数列表匹配。如果编译器支持C++11，则可以使用列表初始化：
```
Bozo fufu{"fufu","le peu"};
```

**警告：** 接受一个参数的构造函数允许使用赋值语法将对象初始化一个值：
```
Classname object = value;
```
这种特性可能导致问题，但第11章将介绍的，可关闭这项特性。

默认构造函数没有参数，因此如果创建对象时没有进行显示地初始化，则将调用构造函数。如果程序中没有提供任何构造函数，则编译器会为程序定义一个默认构造函数；否则，必须自己提供默认构造函数。默认构造函数可以没有任何参数；如果有，则必须给所有参数都提供默认值。

对于未被初始化的对象，程序将使用默认构造函数来创建：
```
Bozo bubi;            // use default
Bozo *pd=new Bozo;   // use default
```

当对象被删除时，程序将调用析构函数，每个类都只能有一个析构函数。析构函数没有返回类型(连void都没有)，也没有参数，其名称为类名称前加上~。例如，BOzo类的析构函数的原型如下：
```
~Bozo();   // class destructor
```
如果构造函数使用类new，则必须提供使用delete的析构函数。

### 10.4 this指针
当类的成员函数的设计这个对象本身时，该如何称呼这个对象？

C++解决这种问题的方法是：使用被称为this的特殊指针。this指针指向用来调用成员函数的对象(this被作为隐藏参数传递给方法)。一般来说，所有的类方法都将this指针设置为调用它的对象的地址。

**注意：** 每个成员函数(包括构造函数和析构函数)都有一个this指针。this指针指向调用对象。如果方法需要引用整个调用对象，则可以使用表达式*this。在函数的括号后面使用const限定符将this限定为const，这样将不能使用this来修改对象的值。

然而，要返回的并不是this，因为this是对象的地址，而是对象本身，即\*this。现在，可以将\*this作为调用对象的别名来完成前面的方法定义。

```
const Stock & Stock::topval(const Stock & s)const
{
    if(s.total_val > total_val)  // total_val是this->total_val的简写
        return s;
    else
        return *this;
}
```
返回类型为引用意味着返回的是调用对象本身，而不是其副本。

### 10.5 对象数组
实际上，声明对象数组的方法与声明标准类型数组相同：
```
Stock mystuff[4];
```




可以用构造函数来初始化数组元素。在这种情况下，必须为每个元素调用构造函数：
```
const int STKS =4;
Stock stocks[STkS] ={
Stock("abc",12.5,20),
Stock("abcd",12.5,20),
Stock("abced",12.5,20),
Stock("abcwe",12.5,20),
};
```
这里的代码使用标准格式对数组进行初始化：用括号括起的、以逗号分隔的值列表。其中，每次构造函数调用表示一个值。如果类包含多个构造函数，则可以对不同的元素使用不同的构造函数：
```
const int STKS =10;
Stock stocks[STkS] ={
Stock("abc",12.5,20),
Stock(),
Stock("abced",12.5,20),
Stock("abcwe",12.5,20),
};
```
上述代码使用Stock(const string & co,long n,double pr)初始化stock[0]和stock[2]，使用构造函数Stock()初始化stock[1]。由于该声明只初始化了数组的部分元素，因此余下的7个元素将使用默认构造函数进行初始化。

初始化对象数组的方案是，首先使用默认构造函数创建数组元素，然后花括号中的构造函数将创建临时对象，然后将临时对象的内容复制到相应的元素中。因此，要创建类对象数组，则这个类必须有默认构造函数。
### 10.6 类作用域
。。。
### 10.7 抽象数据类型
使用类是一种非常好的方式。顾名思义，ADT以通用的方式描述数据类型，而没有引入语言或实现细节。

例如，通过使用栈，可以以这样的方式存储数据，即总是从堆顶添加或删除数据。例如，C++程序使用栈来管理自动变量。当新的自动变量被生成后，它们被添加到堆顶；消亡时，从栈中删除它们。

下面简要地介绍以下栈的特征。首先，栈存储了多个数据项(该特征使得栈成为一个容器——一种更为通用的抽象);其次，栈可由对它执行的操作来描述。
- 可创建空栈。
- 可将数据项添加到堆顶(压入)。
- 可从栈顶删除数据项(弹出)。
- 可查看栈是否填满。
- 可查看栈是否为空。

可以将上述描述转换为一个类声明，其中公有成员函数提供了表示栈操作的接口，而私有数据成员负责存储栈数据。类概念非常适合于ADT方法。

私有部分必须表明数据存储的方式。例如，可以使用常规数组、动态分配数组或更高级的数据结构(如链表)。然而，公有接口应隐藏数据表示，而以通用的术语来表达，如创建栈、压入等。
```

typedef unsigned long Item;
class Stack
{
    private:
        enum {MAX=10};
        Item items[max];
        int top;
    
    public:
        Stack();
        bool isempty()const;
        bool isfull() const;
        bool push(const Item & item);
        bool pop(Item & item);
};
#endif
```

实现类方法：
```
# include "stack.h"


Stack::Stack()
{
    top=0;
}

bool Stack::isempty() const
{
    return top == 0;
}


bool Stack::isfull() const
{
    return top ==MAX;
}

bool Stack::push(const Item & item)
{
    if(top < MAX>)
    {
        item[top++]=item;
        return true;
    }
    else
        return false;
}

bool Stack::pop(Item & item)
{
    if(top>0)
    {
        item = items[--top];
        return true;
    }
    else 
        return false;
}
```

默认构造函数确保所有栈被创建时都为空。pop()和push()的代码确保栈顶被正确地处理。这种保证措施是OOP更可靠的原因之一。







## 11 使用类
C++类特性丰富、复杂、功能强大。


### 11.1 运算符重载
运算符重载是一种形式的C++多态。

C++允许将运算符重载扩展到用户定义的类型。

**重载运算符函数的格式：**
```
operatorop(argument-list)
```
例如，operator+()重载+运算符，operator*()重载*运算符。op必须是有效的C++运算符，不能虚构一个新的符号。
。。。

### 11.2 计算时间：一个运算符重载示例
```

class Time{
    private:
        int hours;
        int minutes;
    public:
        Time();
        Time(int h,int m=0);

        Time sum(const Time & t)const;

        void Show()const;
};
```

mytime0.cpp:
```


...


Time Time::Sum(const Time & t)const
{
    Time sum;
    sum.minutes=minutes + t.minutes;
    sum.hours=hours+t.hours+sum.minutes / 60;
    sum.minutes %=60;
    return sum;
}

...
```


。。。

#### 11.2.1 添加加法运算符
将Time类转换为重载的加法运算符很容易，只要将Sum()的名称改为operator+()即可。

```

class Time{
    private:
        int hours;
        int minutes;
    public:
        Time();
        Time(int h,int m=0);

        Time operator+(const Time & t)const;

        void Show()const;
};
```

。。。

和Sum()一样，operator+()也是由Time对象调用的，它将第二个Time对象作为参数，并返回一个Time对象。因此，可以像调用Sum()那样来调用operator+()方法：
```
total = coding.operator+(fixing);
```
但将该方法命名为operator+()后，也可以使用运算符表示法：
```
total = coding + fixing;
```
这两种表示方法都将调用operator+()方法。注意，在运算符表示法中，运算符左侧的对象(这里为coding)是调用对象，运算符右边的对象(这里为fixing)是作为参数被传递的对象。

总之，operator+()函数的名称使得可以使用函数表示法或运算符表示法来调用它。编译器将根据操作数的类型来确定如何做：
。。。

#### 11.2.2 重载限制



#### 11.2.3 其他重载运算符



### 11.3 友元

你知道，C++控制对类对象私有部分的访问。通常，公有类方法提供唯一的访问途径，但是有时候这种限制太严格，以致于不适合特定的编程问题。在这种情况下，C++提供了另外一种形式的访问权限：友元。

友元有3种：
- 友元函数；
- 友元类；
- 友元成员函数。

通过让函数成为类的友元，可以赋予该函数与类的成员函数相同的权限。下面介绍友元函数，其他两种友元将在第15章介绍。

##### 为何需要友元
在为类重载二元运算符(带两个参数的运算符)常常需要友元。将Time对象乘以实数就属于这种情况，下面来看看。

重载的乘法运算符与其他两种运算符的差别在于，它使用了两种不同的类型。也就是说，加法和减法运算符都结合两个Time值，而乘法运算符将一个Time值与一个double的类型。这限制了运算符的使用方式。记住，左侧的操作数是调用对象。也就是说，下面的语句：
```
A = B*2.75;
```
将被转换为下面的成员函数调用：
```
A = B.operator*(2.75);
```
但下面的语句又如何呢？
```
A = 2.75 * B;
```
从概念上说，2.75\*B应与B*2.75相同，但第一个表达式不对应于成员函数，因为2.75不是Time类型的对象。记住，左侧的操作数应是调用对象，但2.76不是对象。因此，编译器不能使用成员函数调用来替换该表达式。

解决这个难题的一种方式是，告知每个人(包括程序员自己)，只能按B*2.75这种格式编写，不能写成2.75 * B。这是一种对服务器友好——客户警惕解决方案，与OOP无关。

然而，还有另一种解决方式——非成员函数(记住，大多数运算符都可以通过成员函数或非成员函数来重载)。非成员函数不是由对象调用，它使用的所有值(包括对象)都是显示参数。这样，编译器能够将下面的表达式：
```
A = 2.75 * B;
```
与下面的非成员函数调用匹配：
```
A = operator*(2.75，B)；
```
该函数的原型如下：
```
Time operator*(double m,const Time & t);
```
对于非成员函数重载运算符来说，运算符表达式左边的操作数对应于运算符函数的第一个参数，运算符表达式右边的操作数对应于运算符函数的第二个参数。而原来的成员函数则按相反的顺序处理操作数，也就是说，double值乘以Time值。

使用非成员函数可以按所需的顺序获得操作数(先是double，然后是Time)，但引发了一个新问题：非成员函数不能直接访问类的私有数据，至少常规成员函数不能访问。然而，有一类特殊的非成员函数可以访问类的私有成员，它们被称为友元函数。

#### 11.3.1 创建友元
创建友元函数的第一步是将其原型放在类声明中，并在原型声明前加上关键字friend:
```
friend Time operator*(double m, const Time & t);
```
该原型意味着下面两点：
- 虽然operator*()函数是在类声明中声明的，但它不是成员函数，因此不能使用成员运算符来调用；
- 虽然operator*()函数不是成员函数，但它与成员函数的访问权限相同。

第二步是编写函数定义。因为它不是成员函数，所以不要使用Time::限定符。另外，不要走定义中使用关键字friend，其定义应该如下：
```
Time operator*(double m ,const Time & t)
{
    Time result;
    long totalminutes=t.hours* mult * 60 +t.minutes * mult;

    result.hours = totalminutes / 60;
    result.minutes = totalminutes % 60;
    return result;
}
```
有了上述声明和定义后，下面的语句：
```
A =2.75 * B;
```
将转换为如下语句，从而调用刚才定义的非成员函数：
```
A = operator*(2.75,B);
```
总之，类的友元函数是非成员函数，其访问权限与成员函数相同。

##### 友元是否有悖于OOP
乍一看，您可能会认为友元违反了OOP数据隐藏的原则，因为友元机制允许非成员函数访问私有数据。然而，这个观点太片面了。相反，应将友元函数看作类的扩展接口的组成部分。

例如，从概念上看，double乘以Time和Time乘以double是完全相同的。也就是说，前一个要求有友元函数，后一个使用成员函数，这是C++句法的结果，而不是概念上的差别。

通过使用友元函数和类方法，可以用同一个用户接口表达这两种操作。另外请记住，只有类声明可以决定哪一个函数是友元，因此类声明仍然控制了哪些函数可以访问私有数据。**总之，类方法和友元只是表达类接口的两种不同机制。**

实际上，按下面的方式对定义进行修改(交换乘法操作数的顺序)，可以将这个友元函数编写为非友元函数：
```
Time operator*(double m,const Time & t)
{
    return t*m;
}
```
用来的版本显示地访问t.minutes和t.hours，所以它必须是友元。这个版本将Time对象t作为一个整体使用，让成员函数来处理私有值，因此不必是友元，将该版本作为友元也是一个好主意。最重要的是，它将该作为正式类接口的组成部分。其次，如果以后发现需要函数直接访问私有数据，则只需要修改函数定义即可，而不必修改类原型。

**提示：** 如果要为类重载运算符，并将非类的项作为其第一个操作数，则可以用友元函数来反转操作数的顺序。


#### 11.3.2 常用的友元：重载<<运算符
一个很有用的类特性是，可以对<<运算符进行重载，使之能与cout一起来显示对象的内容。与前面介绍的示例相比，这种重载要复杂些，因此我们分两步(而不是一步)来完成。

假设trip是一个Time对象。为显示Time的值，前面使用的是Show()。然而，如果可以像下面这样操作将更好：
```
cout << trip;
```
之所以可以这样做，是因为<<是可被重载的C++运算符之一。实际上，它已经被重载很多次了。最初，<<运算符是C和C++的位运算符，将值中的位左移。ostream类对该运算符进行了重载，将其转换为一个输出工具。前面讲过，cout是一个ostream对象，它是智能的，能够识别所有的C++基本类型。这是因为对于每种基本类型，ostream类声明中都包含了相应的重载的operator<<()定义。也就是说，一个定义使用int参数，一个定义使用double参数，等等。因此，要使cout能够识别Time对象，一种方法是将一个新的函数运算符定义添加到ostream类声明中，但修改iostream文件是个危险的主意，这样做会在标准接口上浪费时间。相反，通过Time类声明来让Time类知道如何使用cout。

##### 1. <<的第一种重载版本
要使Time类知道使用cout，必须使用友元函数。这是什么原因呢？因为下面这样的语句使用两个对象，其中一个是ostream对象(cout):
```
cout << trip;
```
如果使用一个Time成员函数来重载<<，Time对象将是第一个操作数，就像使用成员函数重载*运算符那样。这意味着必须这样使用<<；
```
trip << cout;
```
这样会令人迷惑，但通过使用友元函数，可以像这样重载运算符：
```
void operator<<(ostream & os ,const Time & t)
{
    os <<t.hours <<" hours," <<t.minutes << " minutes";
}
```
这样可以使用下面的语句：
```
cout << trip;
```
按下面这样的格式打印数据：
```
4 hours, 23 minutes
```

##### 友元还是非友元？
。。。



##### 不知道其他ostream对象？
。。。


##### 2. <<的第二种重载版本
前面介绍的实现存在一个问题。像下面这样的语句可以正常工作：
```
cout << trip;
```
















### 11.4 重载运算符：作为成员函数还是非成员函数
对于很多运算符来说，可以选择使用成员函数或非成员函数来实现运算符重载。一般来说，非成员函数应是友元函数，这样它才能直接访问类的私有数据。例如，Time类的加法运算符在Time类声明中的原型如下：
```
Time operator+(const Time & t) const;  // member version
```
这个类也可以使用下面的原型：
```
// nomember version
friend Time operator+(const Time & t1, const Time & t2);
```
加法运算符需要两个操作数。对于成员函数版本来说，一个操作数通过this指针隐式地传递，另一个操作数作为函数参数显示地传递；对于友元版本来说，两个操作数都作为参数来传递。

**注意：** 非成员函数的重载运算符函数所需的形参数目与运算符使用的操作数目相同；而成员版本所需的参数数目少一个，因为其中的一个操作数是被隐式地传递的调用对象。

这两个原型都与表达式T2+T3匹配，其中T2和T3都是Time类型对象。也就是说，编译器将下面的语句：
```
T1 = T2 + T3；
```
转换为下面两个的任何一个：
```
T1 = T2.operator+(T3);
T1 = operator+(T2,T3);
```
记住，在定义运算符时，必须选择其中的一种格式，而不能同时选择这两种格式。因为这两种格式都与同一个表达式匹配，同时定义这两种格式被视为二义性错误，导致编译错误。

那么哪种格式最好呢？对于某些运算符来说，成员函数是唯一合法的选择。在其他情况下，这两种格式没有太大的区别。有时，根据类设计，使用非成员函数版本可能更好(尤其是为类定义类型转换时)。

### 11.5 再谈重载：一个矢量类
。。。


### 11.6 类的自动转换和强制类型转换

先复习一下C++是如何处理内置类型转换的。将一个标准类型变量的值赋给另一种标准类型的变量时，如果这两种类型兼容，则C++自动将这个值转换为接受变量的类型。例如，下面的语句都将导致数值转换类型;
```
long count = 8;
double time = 11;
int side = 3.33;
```
上述赋值语句都是可行的，因为在C++看来，各种数值类型都表示相同的东西——一个数字，同时C++包含用于进行转换的内置规则。然而，这些转换将降低精度。

C++语言不自动转换不兼容的类型。例如，下面的语句是违法的：
```
int * p = 10;  //type clash
```
在无法自动转换时，可以使用强制类型转换：
```
int * p = (int *)10; //ok
```
将指针设置为地址10，这种赋值是否有意义是另一回事。

可以将类定义成与基本类型或另一个类相关，使得从一种类型转换为另一种类型是有意义的。

以两种方式(磅和英石)来表示重量。
```
class Stonewt
{
    private:
        enum {Lbs_per_stn = 14};
        int stone;
        double pds_left;
        double pounds;
    public:
        Stonewt(double lbs);
        Stonewt(int stn, double lbs);
        Stonewt();
        ~Stonewt();
        void show_lbs()const;
        void show_stn()const;
};
#endif
```

stonewt.cpp:
```

Stonewt::Stonewt(double lbs)
{
    stone = int (lbs) / Lbs_per_stn;
    pds_left = int (lbs) % Lbs_per_stn + lbs-int (lbs);
    pounds = lbs;
}


Stonewt::Stonewt(int stn, double lbs)
{
    stone = stn;
    pds_left = lbs;
    pounds = stn * Lbs_per_stn + lbs;
}


Stonewt::Stonewt()
{
    stone = pounds= pds_left = 0;
}

void Stonewt::show_stn()const
{
    cout <<stone << "stone, " <<pds_left <<" pounds \n";
}

void Stonewt::show_lbs()const
{
    cout << pounds << " pounds\n";
    
}

```
因为Stonewt对象表示一个重量，所以可以提供一些将整数或浮点数值转换为Stonewt对象的方法。我们已经这样做了！在C++中，接受一个参数的构造函数为将类型与该参数相同的值转换为类提供了蓝图。

因此，下面的构造函数用于将double类型的值转换为Stonewt类型;
```
Stonewt(double lbs);
```
也就是说，可以编写这样的代码：
```
Stonewt mycat;
mycat = 19.6;
```

程序将使用构造函数Stonewt(double)来创建一个临时的Stonewt对象，并将19.6作为初始化值。随后，采用逐成员赋值方式将该临时对象的内容复制到mycat中。这一过程称为隐式转换，因为它是自动进行的，而不需要显示强制转换。

只有接受一个参数的构造函数才能作为转换函数。下面的构造函数有两个参数，因此不能用来转换类型：
```
Stonewt(int stn, double lbs);
```
然而，如果给第二个参数提供默认值，它便可用于转换int:
```
Stonewt(int stn, double lbs=0);   // int-to-Stonewt conversion
```

将构造函数用作自动转换函数似乎是一项不错的特性。然而，当程序员拥有更丰富的C++经验时，将发现这种自动特性并非总是合乎需要的，因为这会导致意外的类型转换。因此，C++新增了关键字explicit，用于关闭这种自动特性。也就是说，可以这样声明构造函数：
```
explicit Stonewt(double lbs);
```
这将关闭上述示例中介绍的隐式转换，但仍然允许显示转换，即显示强制类型转换：
```
Stonewt mycat;
mycat = 19.6;       // not valid if Stonewt(double) is declared as explicit
mycat = Stonewt(19.6);      // ok,an explicit conversion
mycat = (Stonewt) 19.6;     //ok,old form for explicit typecast
```

**注意：** 只接受一个参数的构造函数定义了从参数类型到类类型的转换。如果使用关键字explicit限定了这种构造函数，则它只能用于显示转换，否则也可以用于隐式转换。

编译器在什么时候将使用Stonewt(double)函数呢？如果使用关键字explicit，则它只能用于显示转换，否则也可以用于下面的隐式转换。
- 将Stonewt对象初始化为double值时。
- 将double值赋给Stonewt对象时。
- 将double值传递给接受Stonewt参数的函数时。
- 返回值被声明为Stonewt的函数试图返回double值时。
- 在上述任意一种情况下，使用可转换为double类型的内置类型时。

下面详细介绍最后一点。函数原型化提供的参数匹配过程，允许使用Stonewt(double)构造函数来转换其他数值类型。也就是说，下面两条语句都首先将int转换为double，然后使用Stonewt(double)构造函数。
```
Stonewt Jumbo(7000); // uses Stonewt(double), converting int to double
Jumbo = 7300;       // uses Stonewt(double), converting int to double
```

然而，当且仅当转换不存在二义性时，才会进行这种二步转换。也就是说，如果这个类还定义了构造函数Stonewt(long)，则编译器将拒绝这些语句，可能指出:int可被转换为long或double，因此调用存在二义性。


```
incog = 27.8;
taft = 325;
```
第一条赋值语句使用接受double参数的构造函数，将27.8转换为一个Stonewt值，这将把incog的pound成员设置为27.8。因为该语句使用了构造函数，所以还将设置stone和pds_left成员。同样，第二条赋值语句将一个int的值转换为double类型，然后使用Stonewt(double)来设置全部3个成员。

最后，请注意下面的函数调用：
```
display(422,2);  //convert 422 to double,then to Stonew
```
display()的原型表明，第一个参数应是Stonewt对象(Stonewt和Stonewt & 形参都与Stonewt实参匹配)。遇到int参数时，编译器查找构造函数Stonewt(int)，以便将该int转换为Stonewt类型。由于没有找到这样的构造函数。因此编译器寻找接受其他内置类型(int可以转换为这种类型)的构造函数。Stonewt(double)构造函数满足这种要求，因此编译器将int转换为double，然后使用Stonewt(double)将其转换为一个Stonewt1对象。

#### 11.6.1 转换函数
是否可以将Stonewt对象转换为double值，就像如下所示：
```
Stonewt wolfe(28.7);
double host = wolfe;
```
可以这样做，但不是使用构造函数。构造函数只用于从某种类型到类类型的转换。要进行相反的转换，必须使用特殊的C++运算符函数——转换函数。

转换函数是用户定义的强制类型转换，可以像使用强制类型转换那样使用它们。例如，如果定义了从Stonewt到double的转换函数，就可以使用下面的转换：
```
Stonewt wolfe(28.7);
double host = double (wolfe);
double thinker = (double) wolfe;
```
也可以让编译器来决定如何做：
```
Stonewt wells(20.3);
double star = wells;
```
编译器发现，右侧是Stonewt类型，而左侧是double类型，因此它将查看程序员是否定义了与此匹配的转换函数。(如果没有找到这样的定义，编译器将生成错误消息，指出无法将Stonewt赋给double。)

那么，如何创建转换函数呢？要转换为typeName类型，需要使用这种形式的转换函数：
```
operator typeName();
```
请注意以下几点：
- 转换函数必须是类方法；
- 转换函数不能指定返回类型；
- 转换函数不能有参数。

例如，转换为double类型的函数的原型如下：
```
operator double();
```
typeName(这里为double)指出了要转换成的类型，因此不需要指定返回类型。转换函数是类方法意味着：它需要通过类对象来调用，从而告知函数要转换的值。因此，函数不需要参数。

要添加stone_wt对象转换为int类型和double类型的函数，需要下面的原型添加到类声明中：
```
operator int();
operator double();
```

修改后的类声明：
```
class Stonewt
{
    private:
        enum {Lbs_per_stn = 14};
        int stone;
        double pds_left;
        double pounds;
    public:
        Stonewt(double lbs);
        Stonewt(int stn, double lbs);
        Stonewt();
        ~Stonewt();
        void show_lbs()const;
        void show_stn()const;
    // conversion functions
        operator int()const;
        operator double()const;
};
#endif
```
。。。

stonewt1.cpp:
```




// conversion functions

Stonewt::operator int()const
{
    return int(pounds + 0.5);
}

Stonewt::operator double()const
{
    return pounds;
}
```

对新的转换函数进行测试，stone1.cpp：
```

int main()
{

    Stonewt poppins(9,2.8);
    double p_wt = poppins;
    cout << "Convert to double =>";
    cout << "Poppins: "<<p_wt << "pounds.\n";
    cout <<"Convert to int =>";
    cout << "Poppins:" << int(poppins) <<"pounds.\n";
    return 0;
}
```
运行结果：
```
Convert to double =>Poppins:128.8 pounds.
Convert to int =>Poppins: 129 pounds.
```
自动应用类型转换
程序中将int(poppins)和cout一起使用。假设省略了显示强制类型转换：
```
cout <<"Poppins: " <<poppins << " pounds.\n";
```
程序会像下面的语句中那样使用隐式转换吗？
```
double p_wt = poppins;
```
答案是否定的。在p_wt示例中，上下文表明，poppins应被转换为double类型。但在cout示例中，并没有指出应转换为int类型还是double类型。在缺少信息时，编译器指出，程序中使用了二义性转换。该语句没有指出要使用什么类型。

有趣的是，如果类只定义了double转换函数，则编译器将接受该语句。这是因为只有一种转换可能，因此不存在二义性。

赋值的情况与此类似。对于当前的类声明来说，编译器将认为下面的语句有二义性而拒绝它。
```
long gonge = poppins;
```
在C++中，int和double值都可以被赋给long变量，所以编译器使用任意一个转换函数都是合法的。编译器不想承担选择转换函数的责任。然而，如果删除了这两个转换函数之一，编译器将接受这条语句。例如，假设省略了double定义，则编译器将使用int转换，将poppins转换为一个int类型的值。然后在将它赋给gone时，将int类型值转换为long类型。

当类定义了两种或更多的转换时，仍可以用显示强制类型转换来指出要使用哪个转换函数/可以使用下面任何一种强制类型转换表示法：
```
long gone = (double) poppins;
long gone = int(poppins);
```
第一条语句将poppins转换为一个double值，然后赋值操作将该double值转换为long类型。同样，第二条语句将poppins首先转换为int类型，随后转换为long。

和构造函数一样，转换函数也有其优缺点。提供执行自动、隐式转换的函数所存在的问题是：在用户不希望进行转换时，转换函数也可能进行转换。例如，假设您在睡眠不足时编写了下面的代码：
```
int ar[20];
...
Stonewt temp(14,4);
...
int Temp = 1;
...
cout << ar[temp] << "!\n";
```
通常，您以为编译器能够捕获诸如使用了对象而不是整数作为数组索引等错误，但Stonewt类定义了一个operator int()，因此Stonewt对象temp将被转换为int 200，并用作数组索引。原则上说，最好使用显示转换，而避免隐式转换。在C++98中，关键字explicit不能用于转换函数，但C++11消除了这种限制。
因此，在C++11中，可将转换运算符声明为显示的：
```
class Stonewt
{
    ...
//conversion functions
    ecplicit operator int()const;
    explicit operator double()const;
};
```
有了这种声明后，需要强制转换时将调用这些运算符。

另一种方法是，用一个功能相同的非转换函数替换该转换函数即可，但仅在被显示调用时，该函数才会执行。也就是说，可以将：
```
Stonewt::operator int(){return int(pounds + 0.5);}
```
替换为：
```
int Stonewt::Stone_to_Int(){ return int(pounds+0.5); }
```
这样，下面的语句将是非法的：
```
int pld = poppins;
```
但如果确实需要这种转换，可以这样做：
```
int plb = poppins.Stone_to_Int();
```
**警告：** 应谨慎地使用隐式转换函数。通常，最好选择仅在被显示调用时才会执行的函数。

总之，C++为类提供了下面的类型转换。
- 只有一个参数的类构造函数用于将类型与该参数相同的值转换为类类型。例如，将int值赋给Stonewt对象时，接受int参数的Stonewt类构造函数将自动调用。然而，在构造函数声明中使用explicit可防止隐式转换，而只允许显示转换。
- 被称为转换函数的特殊类成员运算符函数，用于将类对象转换为其他类型。转换函数是类成员，没有返回类型、没有参数、名为operator typeName()，其中，typeName是对象将被转换成的类型。将类对象赋给typeName变量或将其强制转换为typeName类型时，该转换函数将自动被调用。

#### 11.6.2 转换函数和友元函数
。。。
