## 4 复合类型
复合类型是基于基本整型和浮点类型创建的，影响最为深远的复合类型是类，它是将学习的OOP的堡垒。

### 4.1 数组
#### 1. 声明数组应指出以下三点：
- 存储在每个元素中的值的类型；
- 数组名；
- 数组中的元素数。

声明数组的通用格式：```typeName arrayName [arraySize];```
arraySize指定元素的数目，它必须是整型常数或const值，也可以是常量表达式(如8*sizeof(int))，即其中的值在编译时都是已知的。具体地说，arraySize不能是变量，变量的值是在程序运行时设置的。然而，可以通过使用new运算符来避开这种限制。


#### 2. 初始化数组
C++允许在声明语句中初始化数组元素，只需提供一个初始化列表。

**数组的初始化规则：**
- 只有在定义数组时才能使用初始化，此后就不能使用了，也不能将一个数组赋给另一个数组。
    ```
    int cards[4] = {1,2,3,4};  //okay
    int hands[4];
    hand[4]={5,6,7,9}; // not allowed
    hands=cards;  // not allowed 
    ```
- 可以使用下标分别给数组中的元素赋值。
- 如果只对数组的一部分进行初始化，则编译器将把其他元素设置为0.
- 如果初始化数组方括号内[ ]为空，C++编译器将计算元素个数。(有时是个很糟糕的做法)。

**C++ 11数组初始化方法：**

C++11中的列表初始化新增了一些功能：
- 初始化数组时，可省略等号；
  ```double earnings[2] {1.2e4,1.6e4};```
- 可在大括号内不包含任何东西，这样把所有元素都设置为零：
    ```float balance [10] {};```
- 列表初始化禁止缩窄转换：
    ```long plifs[] ={25,92,3.0};  // not allowed 将浮点数转化为整型是缩窄操作```



### 4.2 字符串
字符串是存储在内存的连续字节中的一系列字符。C++处理字符串的方式有两种。第一种来自C语言，常被称为C-风格字符串(C-style string)。另一种是基于string类库的方法。

#### 1. 创建C-风格字符串

存储在连续字节中的一系列字符意味着可以将字符串存储在char数组中，其中每一字符都位于自己的数组元素中。
C-风格字符串具有一种特殊的性质：以空字符\0结尾，用来标记字符串的结尾。
```
char dog[2]={'a','b'}; // not a string
char cat[2]={'a','\0'};  // a string!
```
这两个数组都是char数组，但只有第二个数组是字符串。空字符对C-风格字符串而言至关重要。

**更好的初始化字符串的方法**：只需使用一个用引号括起的字符串即可。这种字符串被称为字符串常量或字符串字面值。
```
char bird[11]="Mr. Cheeps";
```
用括号括起的字符串隐式地包括结尾的空字符，因此不用显示地包括它。

。。。

注意，字符串常量(使用双引号)不能与字符常量(使用单引号)互换。字符常量(如'S')是字符串编码的简写表示。在ASCII系统上，'S'只是83的另一种写法，因此，下面的语句将83赋给shirt_size:
```
char shirt_size='S';
```
但"S"不是字符常量，它表示的是两个字符(字符S和\0)组成的字符串。更糟糕的是，"S"实际上表示的是字符串所在的内存地址。
因此，下面的语句将试图将一个内存地址赋给shirt_size:
```
char shirt_size = "S";  //illegal type mistach
```

#### 2. 拼接字符串常量
C++允许拼接字符串字面值，即将两个用引号括起的字符串合并为一个。
```
cout << "abc" "def.\n";
cout << "abc def.\n";
cout << "abc"
"def.\n";
```
注意，拼接时不会在被连接的字符串之间添加空格，第二个字符串的第一个字符将紧跟在第一个字符串的最后一个字符(不考虑\0)后面。第一个字符串中的\0字符将被第二个字符串的第一个字符取代。

#### 3. 在数组中使用字符串
要将字符串存储到数组中，最常用的方法有两种——将数组初始化为字符串常量、将键盘或文件输入读入到数组中。
```
const int Size = 15;
char name1[Size];
char name2[Size]="C++owboy";

cin >> name1;
```
sizeof运算符指出整个数组的长度：15字节，但strlen()函数返回的是存储在数组中的字符串的长度，而不是数组本身的长度。另外，strlen()只计算可见的字符，而不把空字符计算在内。如果要存储字符串abc，则要存储该字符串，数组的长度不能短于strlen(abc)+1。
#### 4. 字符串输入
cin是如何确定已完成字符串输入呢?由于不能通过键盘输入空字符，因此cin需要用别的方法来确定字符串的结尾位置。cin使用空白(空格、制表符和换行符)来确定字符串的结束位置。

#### 5. 每次读取一行字符串输入
要将整条短语而不是一个单词作为字符串输入，需要采用另一种字符串读取方法。具体地说，需要采用面向行而不是面向单词的方法。
istream中的类(如cin)提供了一些面向行的类成员函数:getline()和get()。这两个函数都是取一行输入，直到到达换行符。然而，getline()将丢弃换行符，而get()将换行符保留在输入序列中。

1. 面向行的输入:getline()
该函数有两个参数，第一个参数是用来存储输入行的数组的名称，第二个参数是要读取的字符数。如果这个参数为20，则函数最多读取19个字符，余下的空间用来存储自动在结尾处添加的空字符。getline()成员函数在读取指定数目的字符或遇到换行符时停止读取。
例如，将姓名读入到一个包含20个元素的name数组中。
    ```
    cin.getline(name,20);
    ```

2. 面向行的输入:get()
。。。


#### 6. 空行和其他问题
。。。



### 4.3 string类简介

C++98标准通过string类扩展了C++库，因此可以用string类型的变量而不是字符数组来存储字符串。
要使用string类，必须在程序中包含头文件string。string类位于名称空间std中，因此必须提供一条using编译指令，或者使用std::string来引用它。string类定义隐藏了字符串的数组性质，让你能够像处理普通变量那样处理字符串。

#### 1. C++11字符串初始化
C++11也允许将列表初始化用于C-风格字符串和string对象：
    ```
    string third_date={"The Bread Bowl"};
    string fourth_date{"Hank's Fine Eats"};
    ```


**string对象的方式与使用字符数组的比较**：
- 可以使用C-风格字符串来初始化string对象。
- 可以使用cin来将键盘输入存储到string对象。
- 可以使用cout来显示string对象。
- 可以使用数组表示法来访问存储在string对象中的字符。
\
    与使用数组相比，使用string数组更方便，也更安全。从理论上说，可以将char数组视为一组用于存储一个字符串的char存储单元，而string类变量是一个表示字符串的实体。


#### 2. 赋值、拼接和附加
2.1 使用string类时，某些操作比使用数组时更简单。
例如，不能将一个数组赋给另一个数组，但可以将一个string对象赋给另一个string对象。

2.2 string类简化了字符串合并操作。
可以使用运算符+将两个string对象合并起来，还可以使用运算符+=将字符串附加到string对象的末尾。
可以将C-风格字符串或string对象与string对象相加，或将它们附加到string对象的末尾。

#### 3. string类的其他操作
在C++新增string类之前，程序员也需要完成诸如给字符串赋值等工作。对于C-风格字符串，程序员使用C语言库中的函数来完成这些任务。头文件cstring(以前为string.h)提供了这些函数。
\
例如，可以使用函数strcpy()将字符串复制到字符数组中，使用函数strcat()将字符串附加到字符数组末尾：
    ```
    strcpy(charr1,charr2);  // copy charr2 to charr1
    strcat(charr1,charr2);  // append conents of charr2 to charr1
    ```
    处理string对象的语法通常比使用C字符串函数简单，尤其是执行较为复杂的操作时。例如，对于下述操作：
    ```
    str3=str1+str2;
    ```
    使用C-风格字符串时，需要使用的函数如下：
    ```
    strcpy(charr3,charr1);
    strcat(charr3,charr2);
    ```
    另外，使用字符数组时，总是存在目标数组过小，无法存储指定信息的危险。

#### 4. string类I/O
将一行输入读取到数组中的代码：
    ```
    cin.getline(charr,20);
    ```
将一行输入读取到string对象中的的代码：
    ```
    getline(cin,str);
    ```

### 4.4 结构简介
结构是C++OOP堡垒(类)的基石。结构是用户定义的类型。
#### 1. 创建结构
分为定义结构、创建结构变量。
可以同时完成定义结构和创建结构变量的工作：
```
struct perke{
    ...
}ms;
```

结构声明的位置很重要，C++提倡外部结构声明。

还可以创建没有名称的结构类型，方法是省略名称，同时定义一种结构类型和一个这种类型的变量：
```
struct {
    ...
}position; // 创建一个名为position的结构变量。
            //但这种类型没有名称，因此以后无法创建这种类型的变量。
```

#### 2. 初始化结构
和数组一样，使用由逗号分隔值列表，并用花括号括起。
```
inflatable duck ={...};
```
**C++11结构初始化：**
与数组一样，C++11也支持将列表初始化用于结构，且等号(=)是可选的：
```
inflatable duck {...};
```

如果大括号内未包含东西，各个成员都将设置为零。
最后，不允许缩窄转换。


#### 3. 其他结构属性
C++使用户定义的类型与内置类型尽可能相似。例如，可以将结构作为参数传递给函数，也可以让函数返回一个结构。另外，还可以使用赋值运算符(=)将结构赋给另一个同类型的结构，这样结构中每个成员都将设置为另一个结构中相应成员的值，即使成员是数组。这种赋值被称为成员赋值。

#### 4. 结构数组
。。。

### 4.5 共用体
共用体(union)是一种数据格式，它能够存储不同的数据类型，但只能同时存储其中一种类型。

共用体的用途之一是，当数据项使用两种或更多种格式(但不会同时使用)时，可节省空间。
```
struct widget{
    int type;
    union id
    {
        long id_num;
        char id_char[20];
    } id_val;
};
...
widget prize;
if(prize.type == 1)
    cin >> prize.id_val.id_num;
else
    cin >> prize.id_val.id_char;
```
匿名共用体没有名称，其成员将成为位于相同地址处的变量。显然，每次只有一个成员是当前的成员：
```
struct widget
{
    int type;
    union
    {
        long id_num;
        char id_char[20];
    };
};
...
widget prize;
if(prize.type == 1)
    cin >> prize.id_num;
else
    cin >> prize.id_char;
```
由于共用体是匿名的，因此id_num和id_char被视为prize的两个成员，它们的地址相同，所以不需要中间标识符id_val。程序员负责确定当前哪个成员是活动的。

共用体常用于(但并非只用于)节省内存。尤其在嵌入式系统编程中，内存是非常宝贵的。

### 4.6 枚举
C++的enum工具提供了另一种创建符号常量的方式，这种方式可以替代const。
使用enum的句法与使用结构相似：
```
enum spe {red,orange,yellow,green};
```
red\orange\yellow\green对应的整数值0~3，这些常量被称为枚举量。

。。。


### 4.7 指针和自由存储空间
指针是一个变量，其存储的是值的地址，而不是值本身。

1. 声明和初始化指针
    ```
    int * p;
    ```
    \* p的类型为int，由于8运算符被用于指针，因此p变量本身必须是指针，我们说p指向int类型，我们还说p的类型是指向int的指针，或int*。p是指针(地址)，\*p是int，而不是指针。int*是一种类型——指向int的指针。(*运算符两边的空格是可选的)。

    **注意：**在C++中，int*是一种复合类型，是指向int的指针。
\
2. 指针的危险
    极其重要的一点是：在C++中创建指针时，计算机将分配用来存储地址的内存，但不会分配用来存储指针所指向的数据的内存。为数据提供空间是一个独立的步骤，忽略这一步无疑是自找麻烦。
    ```
    long * fellow; //创建一个指向long的指针
    *fellow=223323; 
    ```
    由于fellow没有被初始化，它可能有任何值。不管值是什么，程序都将它解释为存储223323的地址。fellow指向的地方很可能并不是所要存储223323的地方。这种错误可能会导致一些最隐匿、最难以跟踪的bug。
\
3. 指针和数字
指针不是整型，虽然计算机通常把地址当作整数来处理。因此，不能简单地将整数赋给指针，应通过强制类型转换将数字转换为适当的地址类型：
    ```
    int * pt;
    pt=(int *) 0xB8000000;
    ```

4. 使用new来分配内存
对指针的工作方式有一定的了解后，来看看它如何实现在程序运行时分配内存。前面我们都将指针初始化为变量的地址：变量是在编译时分配的有名称的内存，而指针只是为可以通过名称直接访问的内存提供了一个别名。
指针真正的用武之地在于，在运行阶段分配未命名的内存以存储值。在这种情况下，只能通过指针来访问内存。在C语言中，可以使用库函数malloc()来分配内存：在C++中仍然可以这样做，但C++还有更好的方法——new运算符。

在运行阶段为一个int值分配未命名的内存，并使用指针来访问这个值。这里的关键所在是C++的new运算符。程序员要告诉new，需要为哪种数据类型分配内存:new将找到一个长度正确的内存块，并返回该内存块的地址。程序员的责任是将该地址赋给一个指针。
```
int * pn = new int;
```
new int 告诉程序，需要适合存储int的内存。new运算符根据类型来确定需要多少字节的内存。然后，它找到这样的内存，并返回其地址。接下来，将地址赋给pn，pn是被声明为指向int的指针。现在，pn是地址，而*pn是存储在那里的值。

将这种方法与将变量的地址赋给指针进行比较:
```
int higgens;
int * pt=&higgens;
```
在这两种情况下(pn和pt)下，都是将一个int变量的地址赋给了指针。在第二种情况下，可以通过名称higgens来访问该int，在第一种情况下，则只能通过该指针进行访问。这引出了一个问题：pn指向的内存没有名称，如何称呼它呢？我们说pn指向一个数据对象，这里的"对象"不是"面向对象编程"中的对象，而是一样"东西"。术语"数据对象"比"变量"更通用，它指的是为数据项分配的内存块。因此，变量也是数据对象，但pn指向的内存不是变量。乍一看，处理数据对象的指针方法可能不太好用，但它使程序在管理内存方面有更大的控制权。
为一个数据对象(可以是结构，也可以是基本类型)获得并指定分配内存的通用格式如下：
```
typeName * pointer_name = new typeName;
```
对于指针，需要指出的另一点是，new分配的内存块通常是与常规变量声明分配的内存块不同。常规变量的值都存储在栈的内存区域中，而new从被称为堆或自由存储区的内存区域分配内存。

**内存被耗尽**。。。

5. 使用delete释放内存
当需要内存时，可以使用new来请求，这只是C++内存管理数据包中有魅力的一个方面。另一个方面是delete运算符，它使得在使用完内存后，能够将其归还给内存池。这是通向最有效地使用内存的关键一步。归还或释放(free)的内存可供程序的其他部分使用。使用delete时，后面要加上指向内存块的指针(这些内存块最初是用new分配的)：
    ```
    int * ps =new int;
    ...
    delete ps;
    ```
    这将释放ps指向的内存，但不会删除指针ps本身。例如，可以将ps重新指向另一个新分配的内存块。一定要配对地使用new和delete;否则将发生内存泄漏，也就是说，被分配的内存再也无法使用了。如果内存泄漏严重，则程序将由于不断寻找更多内存而终止。
    \
    不要尝试释放已经释放的内存块，C++标准指出，这样做的结果将是不确定的，这意味着什么情况都可能发生。另外，不能使用delete来释放声明变量所获得的内存:
\
6. 使用new来创建动态数组
通常，对于大型数据(如数组、字符串和结构)，应使用new，这正是new的用武之地。
例如，假设要编写一个程序，它是否需要数组取决于运行时用户提供的信息。如果通过声明来创建数组，则在程序被编译时将为它分配内存空间。不管程序最终是否使用数组，数组都在那里，它占用了内存。在编译时给数组分配内存被称为**静态联编**。意味着数组是在编译时加入到程序中的。但使用new时，如果在运行阶段需要数组，则创建它；如果不需要则不创建。还可以在程序运行时选择数组的长度，这被称为**动态联编**。意味着数组是在程序运行时创建的。这种数组叫作动态数组。使用静态联编时，必须在编写程序时指定数组的长度；使用动态联编时，程序将在运行时确定数组的长度。
 
动态数组的两个基本问题：如何使用C++的new运算符创建数组以及如何使用指针访问数组元素。

- a.使用new创建动态数组

    只要将数组的元素类型和元素数目告诉new即可。必须在类型名后加上方括号，其中包含元素数目。
    ```
    int * psome = new int [10];
    ```
    new运算符返回第一个元素的地址给psome。

    当程序使用完new分配的内存块时，应使用delete释放他们。然而，对于使用new创建的数组，应使用另一种格式的delete来释放:
    ```
    delete [] psome;
    ```
    方括号告诉程序，应释放整个数组，而不仅仅是指针指向的元素。

    为数组分配内存的通用格式如下：
    ```
    type_name * pointer_name = new type_name [num_elements];
    ```
    使用new运算符可以确保内存块足以存储num_elements个类型为type_name的元素，而pointer_name将指向第1个元素。
\
- b.使用动态数组
psome它指向包含10个int值的内存块中的第1个元素，从概念上说，将psome看作是一根指向该元素的手指。假设int占4个字节，则将手指沿正确的方向移动4个字节，手指将指向第2个元素。总共10个元素，这就是手指移动的范围。因此，new语句提供了识别内存块中的每一元素所需的全部信息。
从实际角度说，只要把指针当作数组名使用即可。用psome[1/2/3/...]来访问元素。

### 4.8 指针、数组和指针算术
指针和数组等价的原因在于指针算术和C++内部处理数组的方式。将指针变量加1后，增加的量等于它指向的类型的字节数。例外，C++将数组名解释为数组第1个元素的地址。

假设wages为一个double类型的数组，则：
    ```
    double * pw = wages;
    ```
和所有数组一样，wages也存在下面的等式：
    ```
    wages = &wages[0]
    ```

**注意：**将指针变量加1后，其增加的值等于指向的类型占用的字节数。

a.使用数组表示法时，C++都执行下面的转换：
    ```
    arrayname[i] becomes *(arrayname +i)
    ```
b. 如果使用的是指针时，而不是数组名，则C++也将执行同样的转换：
    ```
    pointername[i] becomes *(pointername+i)
    ```
因此，在很多情况下，可以相同的方式使用指针名和数组名。对于它们，可以使用数组方括号表示法，也可以使用解除引用运算符(*)。在多数表达式中，它们都表示地址。区别之一是，可以修改指针的值，而数组名是常量：
```
pointername = pointername+1;  // valid
arrayname=arrayname+1;  // not allowed
```
另一个区别是，对数组应用sizeof运算符得到的是数组的长度(这种情况下，C++不会将数组名解释为地址)，而对指针应用sizeof得到的是指针的长度，即使指针指向的是一个数组。


**数组的地址：**。。。


#### 2. 指针小结
   \
    a. 声明指针
    声明指针通用格式：
    ```
    typeName * pointerName;
    ```
    \
    b. 给指针赋值
    应将内存地址赋给指针。可以对变量名应用&运算符，来获得被命名的内存的地址，new运算符返回未命名的内存的地址。
    \
    c. 对指针解除引用
    对指针解除引用意味着获得指针指向的值。对指针应用解除引用或间接运算符(*)来解除引用。
    \
    d. 区分指针和指针所指向的值
    如果pt时指向int的指针，则*pt是一个int类型的变量。
    \
    e. 数组名
    在多数情况下，C++将数组名视为数组的第一个元素的地址。
    一种例外情况是，将sizeof运算符用于数组名用时，此时将返回整个数组的长度(单位为字节)。
    \
    f. 指针算术
    C++允许将指针和整数相加。加1的结果等于原来的地址值加上指向的对象占用的总字节数。还可以将一个指针减去另一个指针，获得两个指针的差。后一种运算将得到一个整数，仅当两个指针指向同一个数组(也可以指向超出结尾的一个位置)时，这种运算才有意义；这将得到两个元素的间隔。
    ```
    int tacos[3]={1,2,3};
    int * pt=tacos;
    pt=pt+1;
    int * pe =&tacos[2];
    pe=pe-1;
    int diff=pe-pt;
    ```
    \
    g. 数组的动态联编和静态联编
    使用数组声明来创建数组时，将采用静态联编，即数组的长度在编译时设置：
    ```
    int tacos[10];
    ```
    使用new[] 运算符创建数组时，将采用动态联编(动态数组)，即将在运行时为数组分配空间，其长度也将在运行时设置。使用完这种数组后，应使用delete[]释放其占用的内存：
    ```
    int size;
    cin >> size;
    int * pz =new int [size];
    ...
    delete [] pz;
    ```
    \
    h. 数组表示法和指针表示法
    使用方括号数组表示法等同于对指针解除引用：
    ```
    tacos[0] means *tacos
    tacos[3] means *(tacos+3)
    ```
    数组名和指针变量都是如此，因此对于指针和数组名，既可以使用指针表示法，也可以使用数组表示法。

#### 3. 指针和字符串


#### 4. 使用new创建动态结构
在运行时创建数组优于编译时创建数组，对于结构也是如此。通过使用new，可以创建动态结构。
将new用于结构由两步组成：创建结构和访问其成员。
创建结构：
    ```
    inflatable * ps = new inflatable;
    ```
访问其成员：创建动态结构时，不能将成员运算符句点用于结构名，因为这种结构没用名称，只是知道它的地址。C++专门为这种情况提供了一个运算符:箭头成员运算符(->)。




#### 5. 自动存储、静态存储和动态存储
根据用于分配内存的方法，C++有3种管理数据内存的方式：自动存储、静态存储和动态存储(有时也叫作自由存储空间或堆)。还有第四种线程存储。
    \
    **5.1 自动存储**
    在函数内部定义的常规变量使用自动存储空间，被称为自动变量，这意味着它们在所属的函数被调用时自动产生，，在该函数结束时消亡。
    实际上，自动变量是一个局部变量，其作用域为包含它的代码块。
    自动变量通常存储在栈中。这意味着执行代码块时，其中的变量将依次加入到栈中，而在离开代码块时，将按相反的顺序释放这些变量，这被称为后进先出。因此，在程序执行过程中，栈将不断地增大和缩小。
    \
    **5.2 静态存储**
    静态存储是整个程序执行期间都存在的存储方式，使变量成为静态的方式有两种：一种是在函数外面定义它；另一种是在声明变量时使用关键字static。
    自动存储和静态存储的关键在于：这些方法严格地限制了变量的寿命。变量可能存在于程序的整个生命周期(静态变量)，也可能只是在特定函数被执行时存在(自动变量)。
    \
    **5.3 动态存储**
    new和delete运算符提供了一种比自动变量和静态变量更灵活的方法。它们管理了一个内存池，这在C++中被称为自由存储空间或堆。该内存池同用于静态变量和自动变量的内存是分开的。new和delete让您能够在一个函数中分配内存，而在另一个函数中释放它。因此，数据的生命周期不完全受程序或函数的生存时间控制。
    与使用常规变量相比，使用new和delete让程序员对程序如何使用内存有更大的控制权。然而，内存管理也更复杂了。在栈中，自动添加和删除机制使得占用的内存总是连续的，但new和delete的相互影响可能导致占用的自由存储区不连续，这使得跟踪新分配内存的位置更困难。



### 4.9 类型组合


### 4.10 数组的替代品








