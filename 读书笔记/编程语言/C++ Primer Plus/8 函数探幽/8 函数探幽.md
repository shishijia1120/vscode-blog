# 8 函数探幽
## 8.1 C++内联函数

## 8.2 引用变量

C++新增了一种复合类型——引用变量。引用是已定义的变量的别名(另一个名称)。引用变量的主要用途是用作函数的形参。通过将引用变量用作参数，函数将使用原始数据，而不是其副本。这样除指针之外，引用也为函数处理大型结构提供了一种方便的途径，同时对于设计类来说，引用也是必不可少的。

### 8.2.1 创建引用变量
int rats;
int & rodents =rats;

&不是地址运算符，int &指的是指向int的引用，上述引用声明允许将rats和rodents互换——它们指向相同的值和内存单元。

#### 指针和引用的区别

```
int rats=101;
int & rodents =rats;
int * prats=&rats;
```

表达式rodents和\*prats都可以同tats互换，而表达式&rodents和prats都可以同&rats互换。从这一点来说引用看上去很像伪装表示的指针(其中，*解除引用运算符被隐式理解)。实际上，引用还是不同于指针的。除了表示法不同外，还有其他的差别。例如，差别之一是，必须在声明引用时将其初始化，而不能像指针那样，先声明，再赋值：
```
int rat;
int & rodent;
rodent=rat; // can't do this.
```

**注意：**必须在声明引用变量时进行初始化。

引用更接近const指针，必须在创建时进行初始化，一旦与某个变量关联起来，就将一直效忠于它。也就是说：
```
int & rodents =rats;
```
实际上是下述代码的伪装表示：
```
int * const pr=&rats;
```
其中，引用rodents扮演的角色与表达式*pr相同。

**sceref.cpp:**
```
int main()
{
    int rats =101;
    int & rodents =rats;

    cout <<"rats=">>rats;
    cout << ",rodents=">>rodents<<endl;

    cout <<"rats address=">>&rats;
    cout << ",rodents address=">>&rodents<<endl;

    int bunnies=50;
    rodents=bunnies;
    cout <<"bunnies =">>bunnies;
    cout <<"rats=">>rats;
    cout << ",rodents=">>rodents<<endl;

    cout <<"bunnies address =">>&bunnies;
    cout << ",rodents address=">>&rodents<<endl;
    return 0;
}
```

下面是程序输出：
```
rats=101,rodents=101
rats address= 0x0065fd44, rodents address= 0x0065fd44
bunnies=50, rats=50, rodents=50
bunnies address = 0x0065fd48, rodents address= 0x0065fd44
```

最初，rodents引用的是rats，但随后程序试图将rodents作为bunnies的引用：
rodents=bunnies;
乍一看，暂时是成功的，因为rodents的值从101变为了50.但仔细研究将发现，rats也变成了50,同时rats和rodents的地址相同，而该地址与bunnies的地址不同。由于rodents是rats的别名，因此上述赋值语句与下面的语句等效：
rats=bunnies;
也就是说，这意味着"将bunnies变量的值赋给rat变量"。简而言之，可以通过初始化声明来设置引用，但不能通过赋值来设置。
假设程序员试图这样做：
```
int rats=101;
int * pt=&rats;
int & rodents=*pt;
int bunnies=50;
pt=&bunnies;
```
将rodents初始化*pt使得rodents指向rats。接下来将pt改为指向bunnies，并不能改变这样的事实，即rodents引用的是rats。

### 8.2.2 将引用用作函数参数
引用经常被用作函数参数，使得函数中的变量名成为调用程序中的变量别名。这种传递参数的方法称为按引用传递。按引用传递允许被调用的函数能够访问调用函数中的变量。。。。




### 8.2.3 引用的属性和特别之处
。。。


### 8.2.4 将引用用于结构
引用非常适用于结构和类(C++的用户定义类型)。确实，引入引用主要是为了用于这些类型的，而不是基本的内置类型。
使用结构引用参数的方式与使用基本变量引用相同，只需在声明结构参数时使用引用运算符&即可。例如：

```
struct free_throws
{
    std::string name;
    int made;
    int attrmpts;
}
```

则可以这样编写函数原型，在函数中将指向该结构的引用作为参数：
```
void set_pc(free_throws & ft);
```
如果不希望函数修改传入的结构，可使用const:
```
void display(const free_throws & ft);
```

**strtref.cpp**
```
struct free_throws
{
    string name;
    int made;
    int attempts;
    float percent;
};

void display(const free_throws & ft);
void set_pc(free_throws & ft);
free_throws & accumulate(free_throws & target ,const free_throws & source);


int main()
{
    free_throws one ={'If',13,14};
    free_throws two ={'An',10,16};
    free_throws three ={'Mi',7,9};
    free_throws four ={'Wh',5,9};
    free_throws five ={'Lo',6,14};
    free_throws team ={'Th',0,0};
 
    free_throws dup;

    set_pc(one);
    display(one);
    accumulate(team,one);
    display(team);

    display(accumulate(team,two));
    accumulate(accumulate(team,three),four);
    display(team);

    dup=accumulate(team,five);
    cout <<"Displaying team:\n";
    display(team);
    
    cout <<"Displaying dup after assignment:\n";
    display(dup);
    set_pc(four);

    accumulate(dup,five)=four;
    cout <<"Displaying dup after ill-advised assignment:\n";
    display(dup);
    return 0;

}



void display(const free_throe & ft)
{
    cout<<"Name:">> ft.name <<"\n";
    cout<<"Made:">> ft.made <<"\n";
    cout<<"Attempts:">> ft.attempts <<"\n";
    cout<<"Percent:">> ft.percent <<"\n";

}

void set_pc(free_throws & ft)
{
    if(ft.attempts !=0)
        ft.percent=100.0f * float (ft.made)/float (ft.attempts);
    else 
        ft.percent=0;
}

free_throws & accumulate(free_throws & target, const free_throws & source)
{
    target.attempte+=source.attempts;
    target.made+=source.made;
    set_pc(target);
    return target;
}

```
1. 程序说明
P283

2. 为何要返回引用
3. 传统返回机制与按值传递函数参数类似：计算关键字return后面的表达式，并将结果返回给调用函数。从概念上说，这个值被复制到一个临时位置，而调用程序将使用这个值。
```
double m =sqrt(16.0);
cout << sqrt(25.0);
```
在第一条语句中，值4.0被复制到一个临时位置，然后被复制给m。在第二条语句中，值5.0被复制到一个临时位置，然后被传递给cout(这里理论上的描述，编译器可能合并某些步骤)。

现在来看下面的语句：
```
dup=accumulate(team,five);
```
如果accumulate()返回一个结构，而不是指向结构的引用，将把整个结构复制到一个临时位置，再将这个拷贝复制给dup。但在返回值为引用时，将直接把team复制到duo，其效率更高。

**注意：**返回引用的函数实际上是被引用的变量的别名。


3. 返回引用时需要注意的问题
返回引用时最重要的一点是，应避免返回函数终止时不再存在的内存单元引用。你应该避免编写下面这样的代码：
```
const free_throws & clone2(free_throws & ft)
{
    free_throws newguy;
    newguy=ft;
    return newguy;
}
```
给函数返回一个指向临时变量(newguy)的引用，函数运行完毕后它将不再存在。应该避免返回指向临时变量的指针。
为避免这种问题，最简单的方法是，返回一个作为参数传递给函数的引用。作为函数的引用将指向调用函数使用的数据，因此返回的引用也将指向这些数据。
另一种方法是用new来分配新的存储空间。
```
const free_throws & clone (free_throws & ft)
{
    free_throws * pt;
    *pt=ft;
    return *pt;
}
```

。。。
4. 为何将const 用于引用返回类型
。。。



### 8.2.5 将引用用于类对象
将类对象传递给函数时，C++通常的做法是使用引用。例如，可以通过使用引用，让函数将类string、ostream、ofstream和ifstream等类的对象作为参数。

**strquote.cpp:**
```

string version1(const string & s1, const string & s2);
const string & version2(string & s1 ,const sring & s2); // has side effect
const string & version3(string & s1,const string & s2);  //bad design

int main()
{
    string input;
    string copy;
    string result;

    cout<<"Enter a string:";
    getline(cin,input);
    cpoy=input;
    cout<<"Your string as entered:">>input<<endl;
    result=version1(input,"***");
    cout<<"Your string enhanced:">>result<<endl;
    cout<<"Your original string:">>input<<endl;

    result=version2(input,'###');
    cout<<"Your string enhanced:">>reslut<<endl;
    cout<<"Your original string:">>input<<endl;

    cout<<"Resetting original string.\n";
    input=copy;
    result=version3(input,'@@@');
    cout<<"Your string enhanced:">>reslut<<endl;
    cout<<"Your original string:">>input<<endl;

    return 0;
}


string version1(const string & s1,const string & s2)
{
    string temp;

    temp=s2+s1+s2;
    return temp;
}

const string & version2(string & s1, const string & s2) // has side effect
{
    s1=s2+s1+s2;
// safe to return reference passed to function
    return s1;
}

const string & version3(string & s1,const string & s2)  //bad design
{
    string temp;
    temp=s2+s1+s2;
// unsafe to return reference to local variable
    return temp;
}
```
下面是该程序的运行情况：
```
Enter a string；It's not my fault.
Your string as enered；It's not my fault.
Your string enhanced:***It's not my fault.***
Your original string:It's not my default.
Your string enhanced:###It's not my fault.###
Your original string:###It's not my default.###
Resetting orinagal string.
```
此时，该程序已经崩溃。

在version1()中，temp是一个新的string对象，只在函数version1()中有效。该函数执行完毕后，它将不再存在。因此，返回指向temp的引用不可行，因此该函数的返回类型为string，这意味着temp的内容将被复制到一个临时存储单元中，然后在main()中，该存储单元的内容复制到一个名为result的string中：
```
result = version1(input,"***");
```

#### 将C-风格字符串用作string对象引用参数

。。。

由于s1是指向main()中一个对象(input)的引用，因此将s1最为引用返回是安全的。由于s1是指向input的引用，因此，下面一行代码：
```
result=version2(input,'###');
```
与下面的代码等价：
```
version(input,'###');
reslut=input;
```
然而，由于s1是指向input的引用，调用该函数将带来修改input的副作用:
```
Your original string:It's not my default.
Your string enhanced:###It's not my fault.###
Your original string:###It's not my default.###
```
因此，如果要保留原来的字符串的不变，这将是一种错误设计。

```
const string & version3(string & s1,const string & s2)  //bad design
{
    string temp;
    temp=s2+s1+s2;
// unsafe to return reference to local variable
    return temp;
}

```
version3()它存在一个致命的缺陷：返回一个指向version3()中声明的变量的引用。这个函数能够通过编译(但编译器会发出警告)，但当程序试图执行该函数时将崩溃。具体地说，问题是由下面的赋值语句引发的：
```
result=version3(input,"@@@");
```
程序试图引用已经释放的内存。

### 8.2.6 对象、继承和引用

。。。

### 8.2.7 何时使用引用参数
使用引用参数的主要原因有两个。
- 程序员能够修改调用函数中的数据对象。
- 通过传递引用而不是整个数据对象，可以提高程序的运行速度。

当数据对象较大时(如结构和类对象)，第二个原因最重要。这些也是使用指针参数的原因。这是有道理的，因为引用参数实际上是基于指针的代码的另一个接口。那么，什么时候应使用引用、什么时候应使用指针呢？什么时候应按值传递呢？下面是一些指导原则：
对于使用传递的值而不作修改的函数。
- 如果数据对象很小，如内置数据类型或小型结构，则按值传递。
- 如果数据对象是数组，则使用指针，因为这是唯一的选择，并将指针声明为执行const的指针。
- 如果数据对象是较大的结构，则使用const指针或const引用，以提高程序的效率。这样可以节省复制结构所需的时间和空间。
- 如果数据对象是类对象，则使用const引用。类设计的语义常常要求使用引用，这是C++新增这项特性的主要原因。因此，传递类对象参数的标准方式是按引用传递。

对于修改调用函数中数据的函数：
- 如果数据对象是内置数据类型，则使用指针。如果看到诸如fixit(&x)这样的代码(其中x是int)，则很明显，该函数将修改x。(此处书中好像写错了，应该是使用引用)
- 如果数据对象是数组，则只能使用指针。
- 如果数据对象是结构，则使用引用或指针。
- 如果数据对象是类对象，则使用引用。

当然，这只是一些指导原则，很可能有充分的理由做出其他的选择。例如，对于基本类型，cin使用引用，因此可以使用cin>>n，而不是cin>>&n。
