
# 4 复合类型

## 4.1 数组

声明数组的通用格式如下：```typeName arrayName[arraySize];```
表达式arraySize指定元素数目，它必须是整型常数(如10)，也可以是常量表达式(如8*sizeof(int))，即其中所有的值在编译时都是已知的。具体地说，arraySize不能是变量，变量的值是在程序运行时设置的。可使用new运算符来避开这种限制。

**数组的初始化规则**
1. 只有在定义数组时才能使用初始化，此后就不能使用了。也不能将一个数组赋给另一个数组：
```
int cards[4]={1,2,3,4};//okay
int hands[4];        //okay
hands[4]=[1,2,3,4];  // not allowed
hands=cards;    // not allowed
```

2. 初始化数组时，提供的值可以少于数组的元素数目。
```
float hotelTips[5]={5.0,2.5};
```
如果只对数组的一部分进行初始化，则编译器把其他元素设置为0.
如果初始化数组方括号内([])为空，C++编译器将计算元素个数。例如：
```
short things[]={1,5,3,8};
```
编译器将使things数组包含4个元素。(不建议)

**C++11数组初始化方法**
C++11将使用大括号的初始化(列表初始化)作为一种通用初始化方式，可用于所有类型。数组以前就可使用列表初始化。但C++11中的列表初始化新增了一些功能。
1. 首先，初始化数组时，可省略等号(=):
    ```double earnings[4] {1.2e4, 1.6e4, 1.1e4, 1.7e4};```
2. 其次，可不在大括号内包含任何东西，这将把所有元素都设置为零：
   ```float balances[100] {};```
3. 列表初始化禁止缩窄转换：
    ```long plifs[] ={25,92,3.0}; // not allowed```
    ```char slifs[4] {'h','i',1122011,'\0'};  //not allowed```
    ```char tlifs[4] {'h','i',112,'\0'} //allowed```

    在上述代码中，第一条语句不能通过编译，因为将浮点数转换为整型是缩窄操作，即使浮点数的小数点后面为零。第二条语句不能通过编译，因为1122011超出了char变量的取值范围。第三条语句可通过编译，因为虽然112是一个int值，但它在char变量的取值范围内。

## 4.2 字符串
字符串是存储在内存的连续字节中的一系列字符。C++处理字符串的方式有两种。第一种来自C语言，常被称为C-风格字符串。另一种是基于string类库的方法。

存储在连续字节中的一系列字符意味着可以将字符串存储在char数组中，其中每个字符都位于自己的数组元素中。字符串提供了一种存储文本信息的便捷方式。

C-风格字符串具有一种特殊的性质：以空字符(null character)结尾，空字符被写作\0，其中ASCII码为0，用来标记字符串的结尾。
```
char dog[4]={'a','b','c','e'}; // not a string！
char cat[4]={'a','b','c','\0'}; // a string!
```
这两个数组都是char数组，但只有第二个数组是字符串。空字符对C-风格字符串而言至关重要。

在cat数组示例中，将数组初始化为字符串的工作看上去冗长乏味——使用大量单引号，且必须记住加上空字符。不必担心，有更好的将字符数组初始化为字符串的方法——只需使用一个用引号括起的字符串即可，这种字符串被称为字符串常量。
```
char build[11] ="Mr. Cheeps";
char fish[]= "Bubbles";
```
用引号括起的字符串隐式地包括结尾的空字符，因此不用显示地包括它。另外，各种C++输入工具通过键盘输入，将字符串读入到char数组中时，将自动加上结尾的空字符(。。。)。

当然，应确保数组足够大，能够存储字符串中所有字符——包括空字符。使用字符串常量初始化字符数组是这样的一种情况，即让编译器计算元素数目更为安全。让数组比字符串长没有什么害处，只是会浪费一些空间而已。这是因为处理字符串的函数根据空字符的位置，而不是数组长度来进行处理。C++对字符串长度没有限制。

**警告：** 在确定存储字符串所需的最短数组时，别忘了将结尾的空字符计算在内。

注意，字符串常量(使用双引号)不能与字符常量(使用单引号)互换。

```
char shirt_size='S';
```
但"S"不是字符常量，它表示的是两个字符(字符S和\0)组成的字符串。更糟糕的是，"S"实际上表示的是字符串所在的地址。因此下面的语句试图把一个内存地址赋给shirt_size:
```
char shirt_size="S";  // illegal type mismatch
```
由于地址在C++中是一种独立的类型，因此C++编译器不允许这种不合理的做法。
### 4.2.1 拼接字符串常量
有时候，字符串很长，无法放到一行中。C++允许拼接字符串字面值，即将两个用引号括起的字符串合并为一个。

```
cout << "I'd give my right arm to be" "a great violinist.\n";
```
注意，拼接时不会在被拼接的字符串之间添加空格，第二个字符串的第一个字符将紧跟在第一个字符串的最后一个字符(不考虑\0)后面。第一个字符串的\0字符将被第二个字符串的第一个字符取代。

### 4.2.2 在数组中使用字符串
要将字符串存储到数组中，最常用的方法有两种——将数组初始化为字符串常量、将键盘或文件输入读入到数组中。
```


```

### 4.2.3 字符串输入

### 4.2.4 每次读取一行字符串输入

### 4.2.5 混合输入字符串和数字


## 4.3 string类简介
C++98标准通过string类扩展了C++库，因此选择可以使用string类型的变量而不是字符数组来存储字符串。string类使用起来比数组简单，同时提供了将字符串作为一种数据类型的表示方法。

要使用string类，必须在程序中包含头文件string。string类位于名称空间std中，因此你必须提供一条using编译指令，或者使用std::string来引用它。string类定义隐藏了字符串的数组性质，让你能够像处理普通变量那样处理字符串。

#### string对象和字符数组的相同点和不同点
```
int main()
{
    char charr1[20];
    char charr2[20]="jaguar";
    string str1;
    string str2="panther";

    cout << "Enter a kind of feline:";
    cin >> charr1;
    cout<<"Enter anothor kind of feline:";
    cin>>str1;
    cout<<"Here are some feline:\n";
    cout<<charr1>>" "<<charr2>>"" 
        <<str1 >>" "<< str2 >>endl;

    cout<<"The third letter in ">>charr2<<" is">>charr2[2]<<endl;
    cout<<"The third letter in ">>str2<<" is">>str2[2]<<endl;

    return 0;
}

```
运行情况：
```


```
。。。

string对象和字符数组之间的主要区别是，可以将string对象声明为简单变量，而不是数组：
```
string str1;
string str2="panther";
```
类设计让程序能够自动处理string的大小。例如，str1的声明创建一个长度为0的string对象，但程序将输入读取到str1中时，将自动调整str1的长度：
```
cin>>str1;
```
这使得与使用数组相比，使用string对象更方便，也更安全。从理论上来说，可以将char数组视为一组用于存储一个字符串的char存储单元，而string类变量是一个表示字符串的实体。


### 4.3.1 C++字符串初始化
C++11也允许将列表初始化用于C-风格字符串和string对象：
```
char first_data[]={"Le Chapon Dodu"};
string third_date={"The Bread Bowl"};
```
### 4.3.2 赋值、拼接和附加
使用string类，某些操作比使用数组时更简单。例如，不能将一个数组赋给另一个数组，但可以将一个string对象赋给另一个string对象：


string类简化了字符串合并操作。可以使用运算符+将两个string对象合并起来，还可以使用运算符+=将字符串附加到string对象的末尾。
```
string str3;
str3=str1+str2;
str1+=str2;
```

。。。

### 4.3.3 string类的其他操作








### 4.3.4 string类I/O
### 4.3.5 其他形式的字符串字面值







## 4.4 结构简介
结构是一种比数组更灵活的数据格式，结构也是C++OOP堡垒(类)的基石。

### 4.4.1 在程序中使用结构
```
struct inflatable
{
    char name[20];
    float volume;
    double price;
};

int main()
{

    inflatable guest={
        "Gloria",
        1.88,
        29.99
    };

    inflatable pal={
        "Arthur",
        3.12,
        32.99
    };

    cout<<guest.name>>pal.name;
    ...
    return 0;
}

```

### 4.4.2 C++11结构初始化
与数组一样，C++11也支持将列表初始化用于结构，且等号(=)是可选的：
```
inflatable duck {"Daphne",0.12,9.98};
```
如果大括号内没有东西，各个成员都被设置为零。最好，不允许缩窄转换。

### 4.4.3 结构可以将string类作为类成员吗











## 4.5 共用体

## 4.6 枚举


## 4.7 指针和自由存储空间
指针是一个变量，其存储的是值的地址，而不是值本身。
要想找到常规变量的地址，只需对变量应用地址运算符&，就可以获得它的位置。使用常规变量时，值是指定的量，而地址为派生量。

#### 指针与C++基本原理
面向对象编程与传统的过程性编程的区别在于，OOP强调的是在运行阶段(而不是编译阶段)进行决策。

处理存储数据的新策略刚好相反，将地址视为指定的量，而将值视为派生量。一种特殊类型的变量——指针用于存储值得地址。因此，指针名表示的是地址。*运算符被称为间接值或解除引用运算符，将其应用于指针，可以得到该地址处存储的值。

### 4.7.1 声明和初始化指针
计算机需要跟踪指针指向的值的类型。例如，char的地址与double的地址看上去没什么两样，但char和double使用的字节数是不同的，它们存储值时使用的内部格式也不同。因此，指针声明必须指定指针指向的数据的类型。
int * p_updates;
p_updates是指针(地址)，是指向int的指针，而*p_updates是int。

int ducks =12; //创建ducks变量，将值12存储在该变量中。
int * birddog = &ducks; //创建birddog变量，将ducks的地址存储在该变量中。


此处有图P117
。。。

### 4.7.2 指针的危险
极其重要的一点是：在C++中创建指针时，计算机将分配用来存储地址的内存，但不会分配用来存储指针所指向的数据的内存。为数据提供空间是一个独立的步骤，忽略这一步无疑是自找麻烦，如下所示：
long * fellow;
\* fellow=223323;

fellow是一个指针，但它指向哪里呢？上述代码没有将地址赋给fellow。由于fellow没有被初始化，它可能有任何值。不管值是什么，程序都将它解释为存储223323的地址。如果fellow的值碰巧为1200，计算机将把数据放在地址1200上，即使这恰巧是程序代码的地址。fellow指向的地方很可能并不是所要存储223323的地方。这种错误可能会导致一些最隐匿、最难以跟踪的bug。

**警告：**一定要在对指针应用解除引用运算符(*)之前，将指针初始化为一个确定的、适当的地址。这是关于使用指针的金科玉律。

### 4.7.3 指针和数字
指针不是整型，虽然计算机通常把地址当作整数来处理。整数是可以执行加、减、除等运算的数字，而指针描述的是位置，将两个地址相乘没有任何意义。从可以对整数和指针执行的操作上看，它们也是彼此不同的。因此，不能简单地将整数赋给指针。要将数字值作为地址来使用，应通过强制类型转换数字转换为适当的地址类型：
int * pt;
pt=(int *) 0xB8000000;
注意，pt是int的值的地址并不意味着pt本身的类型是int。例如，在有些平台中，int类型是2个字节值，而地址是4个字节值。

### 4.7.4 使用new来分配内存
指针初始化为变量的地址：变量是在编译时分配的有名称的内存，而指针只是为可以通过名称直接访问的内存提供了一个别名。
指针真正的用武之地在于，在运行阶段分配未命名的内存以存储值。在这种情况下，只能通过指针来访问内存。


在运行阶段使用new运算符为一个int值分配未命名的内存，并使用指针来访问这个值。
int * pn =new int;

new int告诉程序，需要适合存储int的内存。new运算符根据类型来确定需要多少字节的内存。然后，它找到这样的内存，并返回其地址。接下来，将地址赋给pn，pn是被声明为指向int的指针。现在，pn是地址，而*pn是存储在那里的值。
。。。


### 4.7.5 使用delete释放内存
使用delete时，后面要加上指向内存块的指针(这些内存块最初是用new分配的)：
int * ps = new int;
...
delete ps;

这将释放ps指向的内存，但不会删除指针ps本身。

**警告：**只能用delete来释放使用new分配的内存。然而，对空指针使用delete是安全的。

注意，使用delete的关键在于，将它用于new分配的内存。这并不意味着要使用用于new的指针，而是用于new的地址：
int * ps = new int;
int * pq =ps;
delete pq;
一般来说，不要创建两个指向同一个内存块的指针，因为这将增加错误地删除同一个内存块两次的可能性。


### 4.7.6 使用new来创建动态数组
通常，对于大型数据(如数组、字符串和结构)，应使用new，这正是new的用武之地。
在编译时给数组分配内存被称为静态联编，意味着数组是在编译时加入到程序中的。但使用new是动态联编，意味着数组是在程序运行时创建的，这种数组叫作动态数组。使用静态联编，必须在编写程序时指定数组的长度；使用动态联编时，程序将在运行时确定数组的长度。

1. 使用new创建动态数组
int * psome =new int [10];
new 运算符返回第一个元素的地址，该地址被赋给指针psome。

当程序使用完new分配的内存块时，应使用delete释放它们。然而，对于使用new创建的数组，应使用另一格式的delete来释放：
delete [] psome;

方括号告诉程序，应释放整个数组，而不仅仅是指针指向的元素。

**使用new和delete，应遵守以下规则：**

2. 使用动态数组
int * psome = new int[3];
psome[0]=1;
psome[1]=2;
psome[2]=3;


**指针和数组名的区别：**
数组名不能修改，但指针是变量，因此可以修改它的值。相邻的int地址通常相差2个字节或4个字节，而将psome加1后，它将指向下一个元素的地址，这表明指针算术有一些特别的地方。

## 4.8 指针、数组和指针算术
指针和数组基本等价的原因在于指针算术和C++内部处理数组的方式。首先，我们来看一看算术，将整数变量加1后，其值将增加1；但将指针变量加1后，增加的量等于它指向的类型的字节数。将指向double的指针加1后，如果系统对double使用8个字节存储，则数值将增加8；

在很多情况下，可以用相同的方式使用指针名和数组名。区别之一是，可以修改指针值，而数组名是常量；
另一个区别是，对数组应用sizeof运算符得到的是数组的长度，而对指针应用sizeof得到的是指针的长度，即使指针指向的是一个数组。


#### 数组的地址
。。。P126



### 4.8.2 指针小结

1. 声明指针
typeName * pointName;
示例：
    double * pn; // pn指向double的指针
    char * pc;  //  pc指向char的指针 
    
2. 给指针赋值
应将内存地址赋给指针。可以对变量名应用&运算符，来获得被命名的内存的地址，new运算符返回未命名的内存的地址。


3. 对指针解除引用
对指针解除引用意味着获得指针指向的值。对指针应用解除引用或间接值运算符(*)来解除引用。
\
另一种对指针解除引用的方法是使用数组表示法，例如，pn[0]与*pn是一样的。决不要对未被初始化为适当地址的指针解除引用。

4. 区分指针和指针所指向的值
如果pt是指向int的指针，则8pt不是指向int的指针，而是完全等同于一个int类型的变量。
int * pt=new int;
 \* pt=5;

5. 数组名
在多数情况下，C++将数组名视为数组的第一个元素的地址。
int tacos[10]; // tacos is the same as &tacos[0]
\
一种例外情况是，将sizeof运算符用于数组名时，此时将返回整个数组的长度(单位为字节)。

6. 指针算术
C++允许将指针和整数相加。加1的结果等于原来的地址值加上指向的对象占用的总字节数。还可以将一个指针减去另一个指针，获得两个指针的差。后一种运算符将得到一个整数，仅当两个指针指向同一个数组(也可以指向超出结尾的一个位置)时，这种运算才有意义：这将得到两个元素的间隔。

7. 数组的动态联编和静态联编
使用数组声明来创建数组时，将采用静态联编，即数组的长度在编译时设置：
int tacos[10];
\
使用new []运算符创建数组时，将采用动态联编(动态数组)，即将在运行时为数组分配空间，其长度也将在运行时设置。使用完这种数组后，应使用delete[]释放其占用的内存。
int size;
cin>>size;
int * pz =new int [size]
...
delete [] pz;

8. 数组表示法和指针表示法
使用方括号数组表示法等同于对指针解除引用：
tacos[0] means *tacos means the value at address tacos
tacos[3] means *(tacos +3) means the value at address tacos+3


### 4.8.3 指针和字符串
。。。

### 4.8.4 使用new创建动态结构

inflatable * ps=new inflatable;
这将把足以存储inflatable结构的一块可用内存的地址赋给ps。
比较棘手的一步是访问成员。创建动态结构时，不能将成员运算符句点用于结构名，因为这种结构没有名称，只是知道它的地址。C++专门为这种情况提供了一个运算符：箭头成员运算符(->)。

### 4.8.5 自动存储、静态存储和动态存储

1. 自动存储
在函数内部定义的常规变量使用自动存储空间，被称为自动变量，这意味着它们在所属的函数被调用时自动产生，在该函数结束时消亡。

自动变量通常存储在栈中。这意味着执行代码块时，其中的变量将依次加入到栈中，而在离开代码块时，将按相反的顺序释放这些变量，这被称为后进后出。因此，在程序执行过程中，栈将不断地增大和缩小。

2. 静态存储
静态存储是整个程序执行期间都存在的存储方式。使变量成为静态的方式有两种：一种是在函数外面定义它；另一种是在声明变量时使用关键字static;
static double fee=56.50;

3. 动态存储
new和delete运算符提供了一种比自动存储和静态存储更为灵活的方法。它们管理了一个内存池，这在C++中被称为自由存储空间或堆。该内存池同用于静态变量和自动变量的内存是分开的。



**栈、堆和内存泄漏**
如果使用new运算符在自由存储空间(或堆)上创建变量后，如果没有调用delete，则即使包含指针的内存由于作用域规则和对象生命周期的原因而被释放，在自由存储空间上动态分配的变量或结构也将继续存在。实际上，将会无法访问自由存储空间中的结构，因为指向这些内存的指针无效。这将导致内存泄漏。被泄漏的内存将在程序的整个生命周期内都不可使用;这些内存被分配出去，但无法收回。极端情况(不过不常见)是，内存泄漏可能会非常严重，以致于应用程序可用的内存被耗尽，出现内存耗尽错误，导致程序崩溃。另外，这种泄漏还会给一些操作系统或在相同的内存空间中运行的应用程序带来负面影响，导致它们崩溃。

要避免内存泄漏，最好是养成这样一种习惯，即同时使用new和delete运算符，在自由存储空间上动态分配内存，随后便释放它。C++智能指针有助于自动完成这种任务，这将在第16章介绍。

## 4.9 类型组合
将数组、结构和指针组合在一起：


1. 指向结构的指针
2. 创建结构数组
3. 创建指针数组
。。。

## 4.10 数组的替代品


### 4.10.1 模板类vector
### 4.10.2 模板类array(C++11)
### 4.10.3 比较数组、vector对象和array对象

