# 6 图
## 6.1 图的基本概念
图是由顶点集合(vertex)及顶点间的关系集合组成的一种数据结构：Graph=(V,E)。

- 完全图：
- 权：
- 邻接顶点：
- 子图：
- 度：
- 路径：
- 路径长度：
- 连通图与连通分量：
- 强连通图与强连通分量：
- 生成树：

### 6.1.1 C


### 6.1.2 C++
1. 图的抽象数据类型
    ```
    class Graph{
        public:
            Graph();
            
            void insertVertex(const T& vertex);
            
            void insertEdge(int v1,int v2,int weight);

            void removeVertex(int v);

            void removeEdge(int v1,int v2);

            bool IsEmpty();

            T getWeight(int v1, int v2);

            int getFirstNeighbor(int v);

            int getNextNeighbor(int v1,int v2);
    };
    ```


----
## 6.2 图的存储结构



### 6.2.1 C


### 6.2.2 C++
#### (1) 图的模板基类
1. **图的模板基类：**
    ```
    const int maxWeight=...;
    const int DefaultVertices=30;
    enum bool {false,true};

    template <class T,class E>
    class Graph{
    public:
        Graoh(int sz=DefaultVertices);
        ~Graph();

        bool GraphEmpty()const{
            if(numEdges==0)return true;
            else return false;
        }

        bool GraphFull()const{
            if(numVertices == maxVertices|| 
                numEdges == maxVertices*(maxVertices-1)/2) return true;
            else return false;
        }

        int NumberOfVertices(){return numVertices;}
        int NumberOfEdges(){return numEdges;}

        virtual T getValue(int i);
        virtual E getWeight(int v1,int v2);

        virtual int getFirstNeighbor(int v);
        virtual int getNextNeighbor(int v,int w);

        virtual bool insertVertex(const T vertex);
        virtual bool insertEdge(int v1,int v2,E cost);
        virtual bool removeVertex(int v);
        virtual bool removeEdge(int v1,int v2);
    private:
        int maxVertices;
        int numEdges;
        int numVertices;
        int getVertexPos(T vertex);
    };
    ```

#### (2) 用邻接矩阵表示的图的类定义
1. **基本定义**
- 无向图邻接矩阵
- 有向图邻接矩阵
- 网络(带权图)邻接矩阵
$$A.Edge[i][j]=\begin{cases}
    W(i,j),\qquad 若(i!=j)同时(<i,j>\in E或(i,j)\in E)\\
    \infty,\qquad \qquad 否则，但i!=j\\
    0,\qquad \qquad \quad若i==j\\
\end{cases}$$

$\qquad$这样第$i$行(列)中权值$0 < W[i][j] < \infty$的顶点数目，就是顶点$i$的出(入)度。




1. **用邻接矩阵表示的图的类定义：**
    ```
    template <class T, class E>
    class Graphmtx:public Graph<T,E>{

    friend istream& operator >>(istream& in, Graphmtx<T,E>& G)；
    friend ostream& operator <<(ostream& out, Graphmtx<T,E>& G);

    public:
        Graphmtx(int sz=DefaultVertices);
        ~Graphmtx(){delete []VerticesList; delete []Edge;}

        T getValue(int i)
            {return i>=0&&i<=numVertices ? VerticesList[i] : NULL;}
        E getWeight(int v1,int v2){}
            {return v1 !=-1 && v2!=-1 ?Edge[v1][v2]:0;}
        
        int getFirstNeighbor(int v);
        int getNextNeighbor(int v,int w);

        bool insertVertex(const T vertex);
        bool insertEdge(int v1,int v2,E cost);
        bool removeVertex(int v);
        bool removeEdge(int v1,int v2)l

    private:
        T * VerticesList;
        E ** Edge;
        int getVertexPos(T vertex){
            for(int i=0;i<numVertices;i++)
                if(VerticesList[i]==Vertex)return i;
            return -1;
        }
    };
    ```
2. **成员函数的实现**
- 3.1 构造函数
    ```
    template <class T, class E>
    Graphmtx<T,E>::Graphmtx(int sz){
        maxVertices=sz;numVertices=0;numEdges=0;
        int i,j;
        VerticesList = new T[maxVertices];      //创建顶点表数组
        Edge = (int * * ) new int * [maxVertices];  //创建邻接矩阵数组
        for(int i=0;i<maxVertices;i++)
            Edge[i]=new int[maxVertices];
        for(i=0;i<maxVertices;i++)          //邻接矩阵初始化
            for(j=0;j<maxVertices;j++)
                Edge[i][j]=(i==j) ? 0 : maxWeight;
    };
    ```
- 3.2 用邻接矩阵表示的图的存取操作的实现
给出顶点位置为v的第一个邻接顶点的位置，如果找不到，则函数返回-1.
    ```
    template <class T, class E>
    int Graphmtx<T,E>::getFirstNeighbor(int v){
        if(v!=-1){
            for(int col=0;col<numVertices;col++)
                if(Edge[v][col]>0 && Edge[v][col] < maxWeight) return col;
        }
        return -1;
    };
    ```
- 3.3 给出顶点v的某邻接顶点w的下一个邻接顶点
```



```



- 3.4 插入顶点vertex
```
template <class T, class E>

```
- 3.5 删去顶点v和所有与它相关联的边
```
template <class T, class E>

```
- 3.6 插入边(v1,v2)，权值为cost
```
template <class T, class E>

```

- 3.7 在图中删去边(v1,v2)
```
template <class T, class E>

```
- 3.8 基于邻接矩阵的图输入的友元重载函数
```
template <class T, class E>

```
- 3.9 基于邻接矩阵的图输出的友元重载函数
```
template <class T, class E>

```

#### (3) 图的邻接表表示
1. **用邻接表表示的图的类定义**


2. **成员函数的实现**


----
## 6.3 图的遍历





----
## 6.4 图的应用
### 6.4.1 最小生成树


### 6.4.2 最短路径