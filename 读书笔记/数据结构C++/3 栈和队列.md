# 3 栈和队列

## 3.1 栈





----

## 3.2 队列
### 3.2.1 队列的基本概念
队列是一种操作受限的线性表，只允许在表的一端进行插入，而在表的另一端进行删除。
#### (1) C
1. 队列常见的基本操作：
    ```
    InitQueue(& Q);
    QueueEmpty(Q);
    EnQueue(&Q,&x);
    DeQueue(&Q,&x);
    GetHead(Q,&x);
    ```

#### (2) C++
1. 用C++描述队列的抽象数据类型：
    ```
    const int maxSize=50;
    class Queue{
        public:
            Queue(){};
            ~Queue(){};
            virtual void EnQueue(const T& x)=0;
            virtual bool DeQueue(T& x)=0;
            virtual bool getFront(T& x)=0;
            virtual bool IsEmpty()const=0;
            virtual bool IsFull()const=0;
            virtual int getSize()const=0;
    };
    ```

### 3.2.2 队列的顺序存储结构
#### (1) C
1. 队列的顺序存储
    ```
    # define MaxSize 50
    typedef struct{
        ElemType data[MaxSize];
        int front,rear;
    }SeqQueue;
    ```

。。。
#### (2) C++
。。。


#### 2. 循环队列
##### (1) C
1. 基础定义
循环队列把存储队列元素的表从逻辑上视为一个环。
- 初始时：Q.front = Q.rear=0
- 队首指针进1：Q.front=(Q.front+1)%MaxSize
- 队尾指针进1：Q.rear=(Q.rear+1)%MaxSize;
- 队列长度：(Q.rear+MaxSize-Q.front)%MaxSize

队空条件：Q.front==Q.rear

为了区分队空还是队满的情况，有三种处理方式：
- 1）牺牲一个单元来区分队空和队满，入队时少用一个队列单元，这是一个较为普遍的做法。约定以"队头指针在队尾指针的下一位置作为队满的标志"
\
队满条件：(Q.rear+1) % MaxSize == Q.front
队空条件：Q.front == Q.rear
队列中元素的个数：(Q.rear-Q.front+MaxSize) % MaxSize
\
- 2）类型中增设表示元素个数的数据成员。这样，队空的条件为Q.size==0;队满的条件为Q.size == MaxSize。这两种情况都有Q.front == Q.rear。
- 3）类型中增设tag数据成员，以区分队满还是队空.tag等于0，若因删除导致Q.front == Q.rear，则为队空；tag等于1时，若因插入导致Q.front==Q.rear,则为队满。


1. 循环队列的操作
- 2.1 初始化
    ```
    void InitQueue(SeqQueue &Q){
        Q.rear=Q.front=0;
    }
    ```

- 2.2 判队空
    ```
    bool isEmpty(SeqQueue Q){
        if(Q.rear==Q.front) return true;
        else return false;
    }
    ```
- 2.3 入队
    ```
    bool EnQueue(SeqQueue &Q, ElemType x){
        if((Q.rear+1)% MaxSize == Q.front) return false;
        Q.data[Q.rear]=x;
        Q.rear=(Q.rear+1)% MaxSize;
        return true;
    }
    ```
- 2.4 出队
    ```
    bool DeQueue(SeqQueue &Q,ElemType &x){
        if(Q.rear==Q.front) return false;
        x=Q.data[Q.front];
        Q.front=(Q.front+1)%MaxSize;
        return true;
    }
    ```

##### (2) C++
1. 循环队列的类定义
    ```
    template <class T>
    class SeqQueue:public Queue<T>{
        public:
            SeqQueue(int sz=10);
            ~SeqQueue(){delete[] elements;};
            
            void EnQueue(const T& x);
            
            bool DeQueue(T& x);
            
            bool getFront(T& x);
            
            bool IsEmpty()const{return (front == rear) ? true:false;}
            
            bool IsFull()const
                {return ((rear+1) % maxSize == front) ? true:false;}
            
            int getSize()const{return (rear-front+maxSize)% maxSize;}

        protected:
            int rear,front;
            T * elements;
            int maxSize;
    };
    ```
2. 成员函数实现
- 2.1 建立一个具有maxSize个元素的空队列
    ```
    template <class T>
    SeqQueue<T>::SeqQueue(int sz):front(0),rear(0),maxSize(sz){
        elements = new T[maxSize];
        assert(elements != NULL);
    };
    ```

- 2.2 入队
    ```
    template <class T>
    bool SeqQueue<T>::EnQueue(const T& x){
        if(IsFull()==true)return false;
        elements[rear] =x;
        rear = (rear+1) % maxSize;
        return true;
    };
    ```
- 2.3 出队
    ```
    template <class T>
    bool SeqQueue<T>::DeQueue(T& x){
        if(IsEmpty()==true) return false;
        x=elements[front];
        front=(front+1)%maxSize;
        return true;
    };
    ```
- 2.4 返回队列头元素的值
    ```
    template <class T>
    bool SeqQueue<T>::getFront(T& x)const{
        if(IsEmpty()==true) return false;
        x=elements[front];
        return true;
    };
    ```


### 3.2.3 队列的链式结构
#### (1) C
1. 不带头结点的链式存储
此处：头指针指向队头结点，尾指针指向队尾结点。
    ```
    typedef struct{
        ElemType data;
        struct LinkNode * next;
    }LinkNode;

    typedef struct{
        LinkNode * front,*rear;
    }LinkQueue;
    ```


2. 带头结点的链式存储
带头结点的单链表能统一插入和删除操作。
- 2.1 初始化
    ```
    void InitQueue(LinkQueue &Q){
        Q.front=Q.rear=(LinkNode*)malloc(sizeof(LinkNode));
        Q.front->next=NULL;
    }
    ```
- 2.2 判队空
    ```
    bool IsEmpty(LinkQueue Q){
        if(Q.front == Q.rear)return true;
        else return false;
    }
    ```
- 2.3 入队
    ```
    void EnQueue(LinkQueue &Q,ElemType x){
        LinkNode * s=(LinkNode *) malloc(sizeof(LinkNode));
        s->data=x;
        s->next=NULL;
        Q.rear->next=s;
        Q.rear=s;
    }
    ```

- 2.4 出队
    ```
    bool DeQueue(LinkQueue &Q,ElemType &x){
        if(Q.front==Q.rear) return false;
        LinkNode * p=Q.front->next;
        x=p->data;
        Q.front->next=p->next;
        if(Q.rear==p)
            Q.rear=Q.front;
        free(p);
        return true;
    }
    ```


#### (2) C++

1. 链式队列的类定义
    ```
    template<class T>
    class LinkedQueue:public Queue<T>{
        public:
            LinkedQueue():rear(NULL),front(NULL){}
            ~LinkedQueue(){makeEmpty();};
            
            bool EnQueue(const T& x);
            
            bool DeQueue(T& x);
            
            bool getFront(T& x)const;
            
            void makeEmpty();

            bool IsEmpty()const{return (front == NULL) ? true:false;}
                     
            int getSize()const;

        protected:
            LinkNode<T> * front, * rear;
    };
    ```

2. 成员函数的实现
- 2.1 置空队列
    ```
    template<class T>
    void LinkedQueue<T>::makeEmpty(){
        LinkNode<T> *p;
        while(front!=NULL){
            p=front;
            front=front->link;
            delete p;
        }
    }
    ```
- 2.2 入队
    ```
    template<class T>
    bool LinkedQueue<T>::EnQueue(const T& x){
        if(front == NULL){
            front = rear =new LinkNode<T>(x);
            if(front == NULL)return false;}
        else{
            rear->link=new LinkNode<T>(x);
            if(rear->link==NULL)return false;
            rear=rear->link;
        }
        return true;
    };
    ```
- 2.3 出队
    ```
    template<class T>
    bool LinkedQueue<T>::DeQueue(T& x){
        if(IsEmpty()==true) return false;
        LinkNode<T> *p=front;
        x=front->data;
        front=front->link;
        delete p;
        return true;
    };
    ```
- 2.4 返回队列头元素
    ```
    template<class T>
    bool LinkedQueue<T>::getFront(T& x)const{
        if(IsEmpty()==true) return false;
        x=front->data;
        return truel
    };
    ```

- 2.5 求队列元素个数
    ```
    template<class T>
    int LinkedQueue<T>::getSize()const{
        LinkNode<T> *p=front;
        int k=0;
        while(p!=NULL){p=p->link;k++;}
        return k;
    };
    ```

### 3.2.4 双端队列
双端队列是指允许两端都可以进行入队和出队操作的队列。其元素的逻辑结构仍是线性结构。将队列的两端分别成为前端和后端，两端都可以入队和出队。

这里涉及到不同的出队序列的问题。
。。。
#### (1) C


。。。
#### (2) C++
##### 一 双端队列的抽象数据类型
1. 双端队列的C++类定义
    ```
    template<class T>
    class Deque:public Queue<T>{
        public:
            virtual bool getHead(T& x)const=0;
            virtual boolgetTail(T& x)const=0;
            
            virtual bool EnQueue(const T& x);
            virtual bool EnQueueHead(const T& x)=0;
            virtual bool EnQueueTail(const T& x)=0;

            virtual bool DeQueue(T& x);
            virtual bool DeQueueHead(T& x)=0;
            virtual bool DeQueueTail(T& x)=0;
    };
    ```
2. 类成员函数的实现
- 2.1 EnQueue
    ```
    template<class T>
    bool Deque<T>::EnQueue(const T& x){
        return EnQueueTail(x);
    };
    ```
- 2.2 DeQueue
    ```
    template<class T>
    bool Deque<T>::DeQueue(T& x){
        T temp;
        bool tag = DeQueueHead(temp);
        x=temp;
        return tag;
    };
    ```

##### 二 双端队列的数组表示
1. SeqDeuqe类的定义
    ```
    template<class T>
    class SeqDeque:public Deque<T>,public SeqQueue<T>{
        public:
            SeqDeque(int sz);
            //...
    };
    ```

2. 类成员函数的实现
- 2.1 getHead
    ```
    template<class T>
    bool SeqQueue<T>::getHead(T& x)const{
        T temp;
        bool tag=SeqQueue<T>::getFront(temp);
        x=temp;
        return tag;
    };
    ```
- 2.2 EnQueueTail
    ```
    template<class T>
    bool SeqQueue<T>::EnQueueTail(T& x){
        return SeqQueue<T>::EnQueue(x);
    };
    ```
- 2.3 DeQueueHead
    ```
    template<class T>
    bool SeqDeque<T>::DeQueueHead(T& x){
        T temp;
        bool tag=SeqQueue<T>::DeQueue(temp);
        x=temp;
        return tag;
    };
    ```
- 2.4 getTail
    ```
    template<class T>
    bool SeqDeque<T>::getTail(T& x)const{
        if(front == rear) return false;
        x=elements[(rear-1+maxSize)% maxSize];
        return true;
    };
    ```
- 2.5 EnQueueHead
    ```
    template<class T>
    bool SeqDeque<T>::EnQueueHead(const T& x){
        if((rear+1)% maxSize == front) return false;
        front = (front-1+maxSize)% maxSzie;
        elements[front]=x;
        return true;
    };
    ```
- 2.6 DeQueueTail
    ```
    template<class T>
    bool SeqQueue<T>::DeQueueTail(T& x){
        if(front == rear) return false;
        rear =(rear-1+maxSize) % maxSize;
        x=elements[rear];
        return true;
    };
    ```
##### 三 双端队列的链表表示
。。。



### 3.2.5 优先队列
。。。


## 3.3 栈和队列的应用

### 3.3.1 栈中括号中匹配中的应用



### 3.3.2 栈在表达式求值中的应用


### 3.3.3 栈在递归中的应用



### 3.3.4 队列在层次遍历中的应用


### 3.3.5 队列在计算机系统中的应用

