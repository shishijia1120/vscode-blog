# 5 树

## 5.1 二叉树的存储表示
。。。






----
## 5.2 二叉树遍历的递归算法
### 5.2.1 前序遍历算法及应用

#### (1) C语言
1. C前序遍历的递归算法
    ```
    void PreOrder(BiTree T){
        if(T!=NULL){
            visit(T);
            PreOrder(T->lchild);
            PreOrder(T->rchild);
        }
    }
    ```


#### (2) C++语言
1. C++前序遍历的递归算法
    ```
    void BinaryTree<T>::PreOrder(BinTreeNode<T> * subTree, void(* visit)(BinTreeNode<T> * p) ){
        if(subTree != NULL){
            visit(subTree);
            PreOrder(subTree->leftChild,visit);
            PreOrder(subTree->rightChild,visit);
        }
    }
    ```


2. 判断两棵是否相等
    ```
    int operator == (const BinaryTree<T> & s , const BinaryTree<T> & t){
        return (equal(s.root,t.root))? true:false;
    } ;

    bool equal(BinTreeNode<T> * a, BinTreeNode<T> * b){
        
        if(a==NULL && b==NULL)return true;
        if(a!=NULL && b!=NULL && a->data == b->data && equal(A_>leftChild, b->leftChild) && equal(a->rightChild,b->rightChild))
            return true;
        else return false;
    };
    ```

3. 利用二叉树前序遍历建立二叉树
    ```
    void BinaryTree<T>::CreateBinTree(ifstream& in,BinTreeNode<T> * & subTree){
        T item;
        if(! in.eof()){
            in >> item;
            if(item != RefValue){
                subTree = new BinTreeNode<T>(item);
                if(subTree == NULL)
                    {cerr << "存储分配错!" << endl; exit(1);}
                CreateBinTree(in,subTree->leftChild);
                CreateBinTree(in,subTree->rightChild);
            }
            else subTree = NULL;
        }
    };
    ```
4. 利用前序输出二叉树
    ```
    void PrintBTree(BinTreeNode<T> * BT){
        if(BT != NULL){
            cout <<BT->data;
            if(BT->leftChild != NULL || BT->rightChild != NULL){
                cout <<'(';
                PrintBTreee(BT->leftChild);
                cout<<',';
                if(BT->rightChild != NULL)
                    printBTree(BT->rightChild);
                cout << ')';
            }
        }
    };
    ```

5. 利用前序序列和中序序列构造二叉树

。。。

6. 树的递归的先根次序遍历算法(树的深度优先遍历)
    ```
    void PreOrder(ostream & out, TreeNode<T> * p){
        if(p != NULL){
            out << p->data;
            for(p=p->firstChild;p!=NULL;p=p->nextSibling)
                PreOrder(out,p);
        }
    };
    ```
7. 利用先根遍历树中的结点总数的算法
    ```
    int Tree<T>::count_node(TreeNode<T> *t)const{
        if(t==NULL)return 0;
        int count=1;
        count+=count_node(t->firstChild);
        cout+=count_node(t->nextSibling);
        return count;
    };
    ```


### 5.2.2 中序遍历算法及应用
#### (1) C语言
1. C中序遍历递归算法
    ```
    void InOrder(BiTree T){
        if(T!=NULL){
            InOrder(T->lchild);
            visit(T);
            InOrder(T->rchild);
        }
    }
    ```
#### (2）C++语言
1. C++中序遍历递归算法
    ```
    void BinaryTree<T>::InOrder(BinTreeNode<T> * subTree, void(* visit) (BinTreeNode<T> *p)){
        if(subTree != NULL){
            InOrder(subTree->leftChild,visit);
            visit(subTree);
            InOrder(subTree->rightChild,visit);
        }
    };
    ```

2. 二叉树计数
。。。

### 5.2.3 后序遍历算法及应用
#### (1) C语言
1. C后序遍历递归算法
    ```
    void PostOrder(BiTree T){
        if(T!=NULL){
            InOrder(T->lchild);
            InOrder(T->rchild);
            visit(T);
        }
    }
    ```

#### (2) C++语言
1. C++后序遍历递归算法
    ```
    void BinaryTree<T>::PostOrder(BinTreeNode<T> * subTree, void(* visit) (BinTreeNode<T> *p)){
        if(subTree != NULL){
            InOrder(subTree->leftChild,visit);
            InOrder(subTree->rightChild,visit);
            visit(subTree);
        }
    };
    ```

2. 利用二叉树后序遍历来计算结点的个数
    ```
    int BinaryTree<T>::Size(BinTreeNode<T> * subTree)const{
        if(subTree == NULL)return 0;
        else return 1+Size(subTree->leftChild)+Size(subTree->rightChild);
    };
    ```

3. 利用二叉树后序遍历来计算二叉树的高度或深度
    ```
    int BinaryTree<T>::Height(BinTreeNode<T> * subTree)const{
        if(subTree == NULL)return 0;
        else{
            int i=Height(subTree->leftChild);
            int j=Height(subTree->rightChild);
            return (i<j)?j+1:i+1;
        }
    };
    ```


4. 树的递归的后根次序遍历算法(树的深度优先遍历)
    ```
    void PostOrder(ostream & out, TreeNode<T> * p){
        if(p!=NULL){
            TreeNode<T> * q;
            for(q=p->firstChild; q!=NULL; q=q->nextSibling)
                PostOrder(out,q);
            out << p->data;
        }
    };
    ```

5. 利用后根遍历求树的深度的算法;
    ```
    int Tree<T>::find_depth(TreeNode<T> *t)const{
        if(t==NULL)return 0;
        int fc_depth=find_depth(t->firstChild)+1;
        int ns_depth=find_depth(t->nextSibling);
        return(fc_depth>ns_depth)?fc_depth:ns_depth;
    };
    ```
----

## 5.3 非递归算法
### 5.3.1 利用栈的前序遍历非递归算法
#### (1) C语言
1. 先序遍历的非递归算法：
    ```
    void PreOrder2(BiTree T){
        InitStack(S);
        BiTree p=T;
        while(p||!IsEmpty(S)){
            if(p){
                visit(p);
                Push(S,p);
                p=p->lchild;
            }
            else{
                Pop(S,p);  
                p=p->rchild;
            }
        }
    }
    ```
#### (2) C++
1. 先序遍历的非递归算法：
    ```
    void BinaryTree<T>::PreOrder(void (* visit) (BinTreeNode<T> * p)){
            stack<BinTreeNode<T> *> S;
            BinTreeNode<T> * p = root;
            S.Push(NULL);
            while(p!=NULL){
                wisit(p);
                if(p->rightChild != NULL)S.push(p->rightChild);
                if(p->leftChild != NULL)p=p->leftChild;
                else S.Pop(p);
            }
        };
    ```
2. 先序遍历的非递归另一种算法：
    ```
    void BinaryTree<T>::PreOrder(void (* visit) (BinTreeNode<T> * p)){
            stack<BinTreeNode<T> *> S;
            BinTreeNode<T> * p ;
            S.Push(root);
            while(!S.IsEmpty()){
                S.Pop(p);
                wisit(p);
                if(p->rightChild != NULL)S.push(p->rightChild);
                if(p->leftChild != NULL)S.Push(=p->leftChild);
            }
        };
    ```

### 5.3.2 层次序遍历
#### (1) C语言
1. 二叉树的层次遍历算法：
    ```
    void LevelOrder(BiTree T){
        InitQueue(Q);
        BiTree p;
        EnQueue(Q,T);
        while(!IsEmpty(Q)){
            DeQueue(Q,p);
            visit(p);
            if(p->lchild!=NULL)
                EnQueue(Q,p->lchild);
            if(p->rchild!=NULL)
                EnQueue(Q,p->rchild);
        }
    }
    ```

#### (2) C++语言
1. 二叉树的层次遍历算法：
    ```
    void BinaryTree<T>::LevelOrder(void (* visit) (BinTreeNode<T> * p)){
        Queue<BinTreeNode<T> *> Q;
        BinTreeNode<T> * p =root;
        Q.EnQueue(p);
        while(!Q.IsEmpty()){
            Q.DeQueue(p);
            visit(p);
            if(p->leftChild!=NULL)Q.EnQueue(p->leftChild);
            if(p->rightChild!=NULL)Q.EnQueue(p->rightChild);
        } 
    };
    ```
### 5.3.3 利用栈的中序遍历非递归算法
#### (1) C语言
1. 中序遍历的非递归算法：
    ```
    void InOrder2(BiTree T){
        InitStack(S);
        BiTree p=T;
        while(p||!IsEmpty(S)){
            if(p){
                Push(S,p);
                p=p->lchild;
            }
            else{
                Pop(S,p);
                visit(p);
                p=p->rchild;
            }
        }
    }
    ```
#### (2) C++语言
。。。



### 5.3.4 利用栈的后序遍历非递归算法
#### (1) C语言
。。。

#### (2) C++语言
。。。


----

## 5.4 线索二叉树
### 5.4.1 利用中序遍历对二叉树进行中序线索化
#### (1) C语言
1. 中序线索二叉树的构造
    ```
    void InThread(ThreadTree & p,ThreadTree & pre){
        if(p!=NULL){
            InThread(p->lchild,pre);
            if(p->lchild==NULL){
                p->lchild=pre;
                p->ltag=1;
            }
            if(pre!=NULL && pre->rchild == NULL){
                pre->rchild=p;
                pre->rtag=1;
            }
            pre=p;
            InThread(p->rchild,pre);
        }
    }

    void CreateInThread(ThreadTree T){
        if(T!=NULL){
            InThread(T,pre);
            pre->rchild=NULL;
            pre->rtag=1;
        }
    }
    ```

2. 中序线索二叉树的遍历
- 2.1 求中序线索二叉树中中序序列下的第一个结点： 
    ```
    ThreadNode * Firstnode(ThreadNode * p){
        while(p->ltag == 0) p=p->lchild;
        return p;
    }
    ```
- 2.2 求中序线索二叉树中结点p中中序序列下的后继：
    ```
    ThreadNode *Nextnode(ThreadNode *p){
        if(p->rtag==0)return Firstnode(p->rchild);
        else return p->rchild;
    }
    ```
- 2.3 利用上面两个算法，写出中序线索二叉树的中序遍历的算法：
    ```
    void Inorder(ThreadNode * T){
        for(ThreadNode *p=Firstnode(T); p!=NULL; p=Nextnode(p))
            visit(p);
    }
    ```
#### (2) C++语言
1. 利用中序遍历对二叉树进行中序线索化：
    ```
    void ThreadTree<T>::createInThread(){
        ThreadNode<T> *pre = NULL;
        if(root != NULL){
            createInThread(root,pre);
            pre->rightChild=NULL;
            pre->rtag = 1;
        }
    };

    void ThreadTree<T>::createInThread(ThreadNode<T> * current, ThreadNode<T> * & pre){
        if(current == NULL)return;
        createInThread(current->leftChild,pre);
        if(current->leftChild == NULL)
            {current->leftChild == NULL;}
        if(pre!=NULL&&pre->rightChild = NULL)
            {pre->rightChild=current;pre->rtag=1;}
        pre = current;
        createInThread(current->rightChild,pre);
    };
    ```

2. 中序线索二叉树的遍历
- 2.1 返回以* current 为根的中序线索二叉树中中序序列下的第一个结点：
    ```
    ThreadNode<T> * ThreadTree<T>::First(ThreadNode<T> * current){
        ThreadNode<T> * p = current;
        while(p->ltag == 0)p=p->leftChild;
        return p;
    };
    ```
- 2.2 返回在中序线索二叉树中结点current在中序下的后继结点：
    ```
    ThreadNode<T> * p = current->rightChild;
    if(current->rtag==0) p=p->rightChild;
    return p;
    ```

- 2.3 在线索化二叉树上执行中序遍历的算法：
    ```
    void ThreadTree<T>::Inorder(void(* visit) (ThreadNode<T> *p)){
        ThreadNode<T> * p;
        for(p=First(root);p!=NULL; p=Next(p))
            visit(p);
    };
    ```

3. 中序线索二叉树的前序遍历算法
    ```
    void ThreadTree::PreOrder(void(*visit) (ThreadNode<T> *p)){
        ThreadNode<T> * p=root;
        while(p!=NULL){
            visit(p);
            if(p->ltag==0) p=p->leftChild;
            else if(p->rtag==0)p=p->rightChild;
                else{
                    while(p!=NULL&& p->rtag==1)
                        p=p->rightChild;
                    if(p!=NULL)p=p->rightChild;
                }
        }
    };
    ```
4. 中序线索二叉树的后序遍历算法
    ```
    void ThreadTree<T>::PostOrder(void (*visit) (ThreadNode<T> * p)){
        ThreadNode<T> * t=root;
        while(t->ltag == 0|| t->rtag == 0)
            if(t->ltag==0)t=t->leftChild;
            else if(t->rtag==0)t=t->rightChild;
        visit(t);
        ThreadNode<T> *p;
        while((p=parent(t))!=NULL){
            if(p->rightChild==t||p->rtag==1)
                t=p;
            else{
                t=p->rightChild;
                while(t->ltag==0||t->rtag==0)
                    if(t->ltag==0)t=t->leftChild;
                    else if(t->rtag==0)t=t->rightChild;
            }
            visit(t);
        }
    };
    ```
----
## 5.4 树、森林
### 5.4.1 树的存储表示
。。。




### 5.4.2 树、森林与二叉树的转换
。。。


### 5.4.3 树和森林的遍历
#### (1) 深度优先遍历
1. 树的递归的先根次序遍历算法(C++):
    ```
    void PreOrder(ostream& out,TreeNode<T> *p){
        if(p!=NULL){
            out<<p->data;
            for(p=p->firstChild;p!=NULL;p=p->nextSibling)
                PreOrder(out,p);
        }
    };
    ```
2. 树的递归的后根次序遍历算法(C++):
    ```
    void PostOrder(ostream& out,TreeNode<T> *p){
        if(p!=NULL){
            TreeNode<T> * q;
            for(q=p->firstChild;q!=NULL;q=q->nextSibling)
                PreOrder(out,q);
            out<<p->data;
        }
    };
    ```
3. 森林的深度优先遍历(C++):
。。。
#### (2) 广度有优先遍历
1. 树的广度优先遍历算法(C++)：
    ```
    void LevelOrder(ostream & out,TreeNode<T> *p){
        Queue<TreeNode<T> *>Q;
        if(p!=NULL){
            Q.EnQueue(p);
            while(!Q.IsEmpty()){
                Q.DeQueue(p);
                out<<p->data;
                for(p=p->firstChild; p!=NULL; p=p->nextSibling)
                    Q.EnQueue(p);
            }
        }
    };
    ```
2. 森林的广度有优先遍历(C++):
。。。


### 5.4.4 树遍历算法的应用
1. 利用先根遍历求树中的结点总数的算法;
    ```
    int Tree<T>::count_node(TreeNode<T> *t)const{
        if(t==NULL)return 0;
        int count=1;
        count+=count_node(t->firstChild);
        cout+=count_node(t->nextSibling);
        return count;
    };
    ```

2. 利用后根遍历求树的深度的算法;
    ```
    int Tree<T>::find_depth(TreeNode<T> *t)const{
        if(t==NULL)return 0;
        int fc_depth=find_depth(t->firstChild)+1;
        int ns_depth=find_depth(t->nextSibling);
        return(fc_depth>ns_depth)?fc_depth:ns_depth;
    };
    ```
---
## 5.5 树与二叉树的应用
### 5.5.1 二叉排序树


### 5.5.2 平衡二叉树



### 5.5.3 哈夫曼树和哈夫曼编码
