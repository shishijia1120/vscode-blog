# 5 树




## 5.3 二叉树的存储表示


### 5.3.1 二叉树的数组存储表示




### 5.3.2 二叉树的链表存储表示


#### 利用二叉链表的二叉树类定义
```

struct BinTreeNode{
    T data;
    BinTreeNode<T> * leftChild,* rightChild;
    BinTreeNode():leftChild(NULL),rightChild(NULL){}
    BinTreeNode(T x ,BinTreeNode<T> * l = NULL, BinTreeNode<T> * r =NULL)
        :data(x),leftChild(l),rightChild(r){}
};


template <class T>
class BinaryTree{
public:
    BinaryTree():root(NULL){}
    BinaryTree(T value:RefValue), root(NULL) {}

}


```


基于以上定义的二叉树部分成员函数的实现如程序所示，关于二叉树的搜索算法Find和插入算法Insert将在介绍二叉树搜索时给出：
```




template <class T>
void BinaryTree<T>::destory(BinTreeNode<T> * subTree){
    if(subTree != NULL){
        destory(subTree -> leftChild);
        destory(subTree->rightChild);
        delete subTree;
    }
};



```





## 5.4 二叉树遍历及其应用


### 5.4.1 二叉树遍历的递归算法



二叉树的中序遍历算法
```

void BinaryTree<T>::InOrder(BinTreeNode<T> * subTree,void (* visit) (BinTreeNode<T> * p)){
    if(subTree !=NULL){
        InOrder(subTree->leftChild,visit);
        visit(subTree);
        InOrder(subTree->rightChild,visit);
    }                            
};
```

二叉树的前序遍历算法
```

void BinaryTree<T>::InOrder(BinTreeNode<T> * subTree,void (* visit) (BinTreeNode<T> * p)){
    if(subTree !=NULL){
        visit(subTree);
        InOrder(subTree->leftChild,visit);
        InOrder(subTree->rightChild,visit);
    }                            
};
```

二叉树的后序遍历算法
```

void BinaryTree<T>::InOrder(BinTreeNode<T> * subTree,void (* visit) (BinTreeNode<T> * p)){
    if(subTree !=NULL){
        InOrder(subTree->leftChild,visit);
        InOrder(subTree->rightChild,visit);
        visit(subTree);
    }                            
};
```

### 5.4.2 二叉树遍历的应用
以上二叉树遍历的方法是构造各种二叉树操作的基础。

#### 1. 二叉树后序遍历的应用
(1)为了计算二叉树的结点个数，可以遍历根节点的左子树和右子树，分别计算出左子树和右子树的结点个数，然后把访问根结点的语句改为相加语句：
```




```




(2)计算二叉树高度的算法相似：如果二叉树为空，空树的高度为0；否则先递归计算根节点左子树的高度和右子树的高度，再求出两者中的大者，并加2(增加根节点时高度加1)，得到整个二叉树的高度。
```





```


#### 2. 二叉树前序遍历的应用

(1)判断两棵二叉树相等的算法
```




```


#### 3. 利用二叉树前序遍历建立二叉树
在此算法中，输入结点值的顺序必须对应二叉树结点前序遍历的属性，并约定以输入序列中不可能出现的值作为空结点的值以结束递归，此值在RefValue中。例如用#或0表示字符序列或正整数序列空结点。

算法的基本思想是：每读入一个值，就为它建立结点。该结点作为根节点，其地址通过函数的应用型参数subTree直接链接到作为实际参数的指针中。然后，分别对根的左、右子树递归地建立子树，直到读入#或0建立空子树递归结束。
```


```



#### 4. 利用前序遍历输出二叉树
如何将二叉树的二叉链表以广义表的形式打印出来。用广义表表示一棵二叉树的规则是：根结点作为广义表的表名放在由左、右子树组成的表的前面，而表是用一对圆括号括起来的。


