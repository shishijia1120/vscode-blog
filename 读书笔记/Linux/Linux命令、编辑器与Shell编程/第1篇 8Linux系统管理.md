### 8 Linux系统管理


#### 8.1 系统服务管理
**服务**：是指操作系统中提供指定功能的程序或进程。服务也是一类应用程序，不同的是服务一般只在后台运行，且服务的对象一般是本地系统或网络中的主机和用户。
在Linux系统中有许多系统服务，这些系统服务涉及Linux运行的各个方面。例如提供打印的服务cups，为系统提供网络支持的服务network，系统网络防火墙服务iptables等。

##### 8.1.1 查看系统服务
Linux系统中存在许多服务，按服务对象不同，通常可以分为本地系统服务和网络服务这两类。本地系统服务主要用于支撑本地系统运行，例如打印、网络支持、防火墙服务、蓝牙支持服务等。网络服务通常用于对网络中的用户或主机提供服务，例如Web服务、代理服务、FTP、数据库服务等。



查看Linux系统中的服务列表，可以使用命令chkconfig。该命令可用于查看服务的自启动状态，也可以设置服务的启动状态。

1. 查询系统防火墙服务iptables的自启动状态：
    ```# chkconfig --list iptables  使用选项list加服务名称，查看指定服务的自启动状态```

2. 如果不使用服务名称参数，命令将会列出系统中的所有服务：
    ```# chkconfig --list```

3. 有时可能会忘记服务的具体名称，也可能只记得服务名称中的一部分，这时可以将chkconfig命令与grep命令一起配合使用。
\
例如要查询服务名称中含有nfs的服务列表：
    ```# chkcofig --list | grep nfs 先使用chkconfig命令列出所有服务，然后使用grep命令筛选含有nfs的行```

##### 8.1.2 设置服务自启动状态
许多时候管理员都需要设置服务的自启动状态，关闭一些不需要的服务，或将需要的服务设置为在相应的运行级别启动等。

一个比较典型的例子：当系统供个人用户使用时，需要禁用网络服务，并且按个人需求禁用不必要的服务，以节省资源(例如没有打印机时，禁用打印服务)。

1. 设置独立服务系统防火墙的自启动状态为关闭：
    ```# chkconfig iptables off 使用chkconfig命令设置防火墙服务的自启动状态为关闭```
    ```# chkonfig --list iptables 使用选项list查看并验证结果```

这时系统防火墙在所有运行级别下都为关闭状态。

2. 如果要设置开启防火墙，可以用如下命令：
    ```# chkconfig iptables on 使用chkconfig命令设置防火墙的自启动状态为开启，并验证设置```
    ```# chkonfig --list iptables 使用选项list查看并验证结果```
这时防火墙会在运行级别为2，3，4，5时自动启动。

3. 从上面几个示例命令的结果中可以看出，设置服务为开启状态时，命令默认将其设置为运行级别2，3，4，5为开启。设置服务关闭时，默认设置为所有运行级别关闭。显然这个默认设置并不适用于所有用户和服务，这时可以使用选项level指定运行级别列表。
\
    例如设置系统防火墙在运行级别3，5自动启动：
    ```# chkconfig --level 35 iptables on  使用选型level设置自启动运行级别列表并验证```
    ```# chkonfig --list iptables 使用选项list查看并验证结果```

4. 对于非独立服务而言，由于没有运行级别这个概念，因此不能使用level选项指定运行级别列表，可以直接设置这些服务的状态。
\
例如要将简单文件传输协议(TFTP)服务设置为开机自启动：
    ```# chkconfig tftp on 使用chkconfig命令设置非独立服务的启动状态并验证```
    ```# chkonfig --list tftp 使用选项list查看并验证结果```

##### 8.1.3 添加删除系统服务
chkconfig命令不仅可以查看、设置服务的自启动状态，还可以添加系统服务(前提条件是有可供使用的运行级别脚本)。

**命令格式**
    ```chkconfig -add <name>```
    ```chkconfig -del <name>```
   

##### 8.1.4 启动和关闭服务命令service
许多时候需要在系统处于运行状态时启动和关闭某个服务。最常见的例子是管理员在配置一个服务时，需要反复关闭、启动服务(启动时服务将重新读取配置文件)，已验证配置文件是否能够达到预期的目的。

**命令格式**
    ```service name [start|stop|restart]```
1. 例如要关闭系统防火墙iptables:
    ```# service iptables stop 使用service命令关闭系统防火墙```
2. 有时修改了服务的配置文件，希望以新的配置文件运行服务，这时可以使用restart参数让服务重启动，已重新读取配置文件。
例如管理员通过修改配置文件的方法重新配置了网络接口卡的IP地址等信息，并希望系统网络重新启动：
    ```# service network restart 使用service重新启动网络支持服务network```
执行以上命令后，系统会先关闭网络支持服务network，然后再读取配置文件，并使用新的配置文件并启动网络接口。
3. 然而有些发行版不支持service命令，由于服务的启动脚本都放在目录/etc/init.d中，因此可以使用手动运行的方式执行启动脚本。
4. 许多服务处理启动、停止和重启之外，还要一些其他动作，如保存、重新载入配置文件等(并非所有服务都支持这些动作)。
\
例如要保存系统防火墙规则：
    ```# service iptables save 使用save动作保存防火墙规则```


#### 8.2 进程管理命令
许多Linux系统运行于多用户环境下，管理员有必要

##### 8.2.1 查看进程命令ps
要查看系统中运行的进程，可以使用ps命令，这是查看系统进程最常用的一个命令。ps命令会输出系统中的进程详细信息，管理员可以利用这些信息杀死进程，也可以管理系统中的进程。

**命令格式**
```ps [option]```
常用选项
- a:显示所有终端进程
- u:显示所有用户的进程
- x:显示所有进程，包括没有明确终端的进程
- e:显示所有的进程，但使用的格式为BSD系统格式
- f:显示UID，PPID(父进程ID)

1. 如果不加任何参数，ps命令将会输出当前用户的进程：
```# ps 以普通用户身份运行ps命令```


##### 8.2.2 进程树
在Linux系统中，父进程、子进程之间的关系非常复杂。

例如，查看当前系统中的进程树：
    ```# pstree  使用pstree命令查看当前系统中的进程树 ```

##### 8.2.3 实时显示进程命令top

1. 使用top命令时，无须使用任何参数和选项：
    ```top ```
2. 
##### 8.2.4 将任务放在后台执行
执行一个花费时间很长的命令时，命令会长时间占用终端前台，这对于用户而言可能会非常不方便。


使用sleep命令作为示例，该命令产生的进程会在指定时间内一直处于睡眠状态，直到时间结束，才退出并释放占用系统资源。如果在前台执行，此命令将会锁住终端直到时间结束。
**在执行命令时，可以在命令最后加入符号&，此时系统会将命令或程序放入后台执行。**

1. 例如要创建一个sleep进程，持续时间为300秒，并将其切换至后台运行：
    ```# sleep 300 & 使用&将命令放在后台执行```
    ```# ps 使用ps命令查看后台进程```

上面这个示例中，命令sleep开始执行即会立即切换至后台，使用ps命令即可发现sleep进程正在后台执行。

2. 使用&将命令放在后台执行时，处于后台的命令会直接将输出和错误信息输出到控制台。这样非常不方便查看，此时建议使用重定向将命令输出、错误信息输出到文件，以便于时候查看。
   \
    例如使用mv命令移动数据时，将错误重定向：
    ```# mv /mnt/sdd5/test /root/ &>message &```

##### 8.2.5 查看后台任务命令jobs
有时要将放在后台执行的命令重新放到前台，将命令放到前台之前，需要知道命令的作业号，要查看后台任务的作业号，可以使用命令jobs。
要查看处于后台任务的作业号：
    ```# jobs 使用jobs命令查看后台执行的命令```

使用jobs命令时需要注意，该命令显示的后台任务是用户手动执行的，需要占用前台的命令，不包含系统运行的后台进程。

##### 8.2.6 后台任务调至前台命令fg
许多时候需要将原本处于后台执行的任务重新放到前台，可能的情况是用户已经完成其他任务，也可能是用户想要查看任务的进度等。这时可以使用fg命令将后台任务重新调至前台执行。

使用fg命令调取任务时，需要使用任务的作业号作为参数。例如将指定的作业重新放到前台执行；
    ```# sleep 60 & 使用&符号将任务放至后台执行```
    ```# jobs 使用jobs命令查看后台任务的作业号```
    ```# fg 1 使用fg命令将作业号为1的任务放到前台执行```

##### 8.2.7 终止进程命令kill
许多时候需要强行终止一个进程，可能的情况是不再需要继续运行这个进程，也可能是这个进程没有响应需要终止等。

**命令格式**
    ```kill -signal PID```

1. 大多数时候，并不需要发送特别的信号，而是以正常方式杀死进程。以正常方式杀死进程时，kill命令将使用信号15，即DIGTERM(使用软件终止的方式)。
这种方式会存在一些问题：进程的子进程可能会无法终止，并继续占用系统资源。
   
    此处以命令sleep作为示例：
    ```# ps 使用ps命令查看终止命令的PID号```
    ```# kill 16888 使用kill命令终止PID为16888的进程```


2. 如果管理员发现某个进程无法终止，可能的原因是进程已经无法响应。这时可以使用信号9，强制终止无法终止的进程：


未完待续

##### 8.2.8 查看进程优先级
##### 8.2.9 指定进程运行优先级命令nice

##### 8.2.10 改变进程优先级命令renice



#### 8.3 计划任务命令crontab、at


#### 8.4 日志管理