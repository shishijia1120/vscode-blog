# 2 线性表

## 2.1 线性表的定义和基本操作
### 2.1.1 线性表的定义
。。。

### 2.1.2 线性表的基本操作
- InitList(&L):初始化表
- Length(L):求表长
- LocateElem(L,e):按值查找操作
- GetElem(L,i):按位查找
- ListInsert(&L,i,e):插入操作
- ListDelete(&L,i,&e):删除操作。删除表L中第i个位置的元素，并用e返回删除元素的值。
- PrintList(L):输出操作。
- Empty(L):判空操作。
- DestroyList(&L):销毁操作。

## 2.2 线性表的顺序表示
### 2.2.1 顺序表的定义
顺序表是用一组地址连续的存储单元依次存储线性表中的数据元素，从而使得逻辑上相邻的两个元素在物理位置上也相邻。
1. 顺序表的静态分配类型定义：
    ```
    # define MaxSize 50
    typedef struct{
        ElemType data[MaxSize];
        int length;
    }SqList;
    ```

2. 顺序表的动态分配类型定义：
    ```
    # define InitSize 100
    typedef struct{
        ElemType * data;
        int MaxSize,length;
    }SeqList;
    ```

C的初始动态分配语句为:
```
L.data=(ElemType*)malloc(sizeof(ElemType)* InitSize);
```
C++的初始动态分配语句为：
```
L.data=new ElemType[InitSize];
```

### 2.2.2 顺序表上基本操作的实现
- 1. 插入操作：
    ```
    bool ListInsert(SqList &L,int i,ElemType e){
        if(i<1||i>L.length+1)
            return false;
        if(L.length >=MaxSzie)
            return false;
        for(int j=L.Length;j>=i;j--)
            L.data[j]=L.data[j-1];
        L.data[i-1]=e;
        L.length++;
        return true;
    }
    ```
注意区分顺序表的位序和数组下标。

最好情况：在表尾插入(i=n+1)，时间复杂度$O(1)$。
最坏情况：在表头插入(i=1)，元素后移语句将执行n次，时间复杂度$O(n)$。
平均情况：所需移动结点的平均次数为$$\sum_{i=1}^{n+1} p_i(n-i+1) =sum_{i=1}^{n+1}\frac{1}{n+1}(n-i+1)=\frac{n}{2}$$
因此，线性表插入算法的平均时间复杂度为$O(n)$。
- 2. 删除操作：
    ```
    bool ListDelete(SqList &L,int i,Elemtype &e){
        if(i<1|| i>L.length)
            return false;
        e=L.data[i-1];
        for(int j=i;j<L.length;j++)
            L.data[j-1]=L.data[j];
        L.length--;
        return true;
    }   
    ```
最好情况：删除表尾元素(i=n)，无须移动元素，时间复杂度$O(1)$.
最坏情况：删除表头元素(i=1)，时间复杂度$O(n)$
平均情况：所需移动结点的平均次数为$$\sum_{i=1}^n p_i(n-i) =sum_{i=1}^n\frac{1}{n}(n-i)=\frac{n-1}{2}$$
因此，线性表删除算法的平均时间复杂度为$O(n)$。
- 3. 按值查找(顺序查找)操作：
    ```
    int LocateElem(SqList L,ElemType e){
        int i;
        for(i=0;i<L.length;i++)
            if(L.data[i]==e)
                return i+1;
        return 0;
    }
    ```
最好情况：查找表头元素，仅需比较一次，时间复杂度$O(1)$.
最坏情况：查找表尾元素(或不存在)，需要比较n次，时间复杂度$O(n)$.
平均情况：所需比较结点的平均次数为$$\sum_{i=1}^n p_i\times i =sum_{i=1}^n\frac{1}{n}\times i=\frac{n+1}{2}$$
因此，线性表查找算法的平均时间复杂度为$O(n)$。

## 2.3 线性表的链式表示
### 2.3.1 单链表的定义
```
typedef struct LNode{
    ElemType data;
    struct LNode * next;
}LNode,*LinkList;
```

头结点和头指针的区分：不管带不带头结点，头指针始终指向链表的第一个结点，而头结点是带头结点的链表中的第一个结点，结点内通常不存储信息。

**引入头结点的优点**：
- 由于第一个数据结点的位置被存放在头结点的指针域中，所以在链表的第一个位置上的操作和在表的其他位置上的操作一致，无须进行特殊处理。
- 无论链表是否为空，其头指针都指向头结点的非空指针(空表中头结点的指针域为空)，因此空表和非空表的处理也就得到了统一。
### 2.3.2 单链表上基本操作的实现
1. 采用头插法建立单链表
```
LinkList List_HeadInsert(LinkList &L){
    LNode *s;
    int x;
    L=(LinkList)malloc(sizeof(LNode));
    L->next=NULL;
    scanf("%d",&x);
    while(x!=NULL){
        s=(LNode *)malloc(sizeof(LNode));
        s->data=x;
        s->next=L->next;
        L->next=s;
        sacnf("%d",&x);
    }
    return L;
}
```
采用头插法建立单链表时，读入数据的顺序与生成的链表中的元素的顺序是相反的。每个结点插入的时间为$o(1)$，设单链表长为$n$，则总时间复杂度$O(n)$。
2. 采用尾插法建立单链表
头插法建立单链表的算法虽然简单，但生成的链表中结点的次序和输入数据的顺序不一致。若希望两者次序一致，则可采用尾插法。该方法将新结点插入到当前链表的表尾，为此必须增加一个尾指针r，使其始终指向当前链表的尾结点。
```
LinkList List_TailInsert(LinkList &L){
    int x;
    L=(LinkList)malloc(sizeof(LNode));
    LNode * s,*r=L;
    scanf("%d",&x);
    while(x!=9999){
        s=(LNode*)malloc(sizeof(LNode));
        s->data=x;
        r->next=s;
        r=s;
        sacnf("%d",&x);
    }
    r->next=NULL;
    return L;
}
```
因为附设了一个指向表尾结点的指针，故时间复杂度和头插法的相同。
3. 按序号查找结点值
```
LNode * GetElem(LinkList L,int i){
    int j=1;
    LNode *p=L->next;
    if(i==0)
        return L;
    if(i<1)
        return NULL;
    while(p&&j<i){
        p=p->next;
        j++;
    }
    return p;
}
```
按序号查找操作的时间复杂度$O(n)$。
4. 按值查找表结点
```
LNode * LocateElem(LinkList L,ElemType e){
    LNode * p=L->next;
    while(p!=NULL && p->data!=e){
        p=p->next;
    }
    return p;
}
```
按值查找操作的时间复杂度$O(n)$。
5. 插入结点操作(后插操作)
```
p=GetElem(L,i-1);
s->next=p->next;
p->next=s;
```
**扩展：对某一结点进行前插操作**。
。。。

6. 删除结点操作
删除结点操作是将单链表的第i个结点删除。先检查删除位置的合法性，后查找表中第i-1个个结点，即被删结点的前驱结点，再将其删除。
```
p=GetElem(L,i-1);
q=p->next;
p->next=q->next;
free(q);
```
和插入算法一样，该算法的主要时间也耗费在查找操作上，时间复杂度为$O(n)$。

**扩展：删除结点*p**。
。。。


1. 求表长操作(不含头结点)


### 2.3.3 双链表
单链表结点中只要一个指向其后继的指针，使得单链表只能从头结点依次顺序地向后遍历。要访问某个结点的前驱结点(插入、删除操作时)，只能从头开始遍历，访问后继结点的时间复杂度为$O(1)$，访问前驱结点的时间复杂度为$O(n)$。

```
typedef struct DNode{
    ElemType data;
    struct DNode * prior, * next;
}DNode, *DLinkList;
```
双链表在按值查找和按位查找的操作与单链表的相同，但双链表在插入和删除操作的实现上，与单链表有着较大的不同。
插入和删除操作的时间复杂度为$O(1)$。

1. 双链表的插入操作
在双链表中p所指的结点之后插入结点*s。
```
s->next=p->next;
p->next->prior=s;
s->prior=p;
p->next=s;
```

2. 双链表的删除操作
删除双链表中结点*p的后继结点\*q。
```
p->next=q->next;
q->next->prior=p;
free(q);
```

### 2.3.4 循环链表
1. 循环单链表
循环单链表和单链表的区别在于，表中最后一个结点的指针不是NULL，而改为指向头结点，从而整个链表形成一个环。

在循环单链表中，表尾结点*r的next域指向L，故表中没有指针域为NULL的结点，因此，循环单链表的判空条件不是头结点的指针是否为空，而是它是否等于头指针。

循环单链表的插入、删除算法与单链表的几乎一样，所不同的是若操作是在表尾进行，则执行的操作不同，以让单链表继续保持循环的性质。因为在任何一个位置上的插入和删除都是等价的，无须判断是否是表尾。

有时队单链表常做的操作是在表头和表尾进行的，此时对循环单链表不设头指针而设尾指针，从而使得操作效率更高。其原因是，若设的是头指针，对表尾进行操作需要$O(n)$的时间复杂度，而若设的是尾指针r,r->next即为头指针，对于表头和表尾进行操作都只需要0(1)的时间复杂度。

2. 循环双链表
在循环双链表中，头结点的prior指针还要指向表尾结点。

在循环双链表中，某结点*p为尾结点时，p->next==L;当循环双链表为空表时，其头结点的prior域和next域都等于L。

### 2.3.5 静态链表
静态链表借助数组来描述线性表的链式存储结构，结点也有数据域data和指针域next，这里的指针是结点的相对地址(数组下标)，又称游标。和顺序表一样，静态链表也要先预先分配一块连续的内存空间。
```
#define MaxSize 50
typedef struct{
    ElemType data;
    int next;
}SLinkList[MaxSize];
```
静态链表以next==-1作为其结束的标志。

### 2.3.6 顺序表和链表的比较
1. 存取(读写)方式
2. 逻辑结构和物理结构
3. 查找、插入和删除操作
4. 空间分配

如何选取存储结构？
1. 基于存储和考虑
2. 基于运算的考虑
3. 基于环境的考虑