# 3 栈和队列

## 3.1 栈
### 3.1.1 栈的基本概念
1. 栈的定义
栈是只允许在一端进行插入或删除操作的线性表。
- 栈顶(Top):
- 栈底(Bottom):
- 空栈：

栈的数学性质：n个不同元素进栈，出栈元素不同排列的个数为$\frac{1}{n+1}C_{2n}^n$。

2. 栈的基本操作
- InitStack(&S):
- StackEmpty(S):
- Push(&S,x):
- Pop(&S,x):
- GetTop(S,&x):
- DestoryStack(&S):

在解答算法题时，若题干未做出限制，则可直接使用这些基本的操作函数。

### 3.1.2 栈的顺序存储结构
1. 顺序栈的实现
```
# define MaxSize 50
typedef struct{
    ElemType data[MaxSize];
    int top;
}SqStack;
```

- 栈空条件：S.top==-1
- 栈满条件：S.top==MaxSize-1
- 栈长：S.top=1


2. 顺序栈的基本运算
。。。







3. 共享栈


。。。




### 3.1.3 栈的链式存储结构
通常采用单链表实现，并规定所有操作都是在单链表的表头进行的。这里规定链栈没有头结点，Lhead指向栈顶元素。
```
typedef struct Linknode{
    ElemType data;
    struct Linknode *next;
}*LiStack;
```

## 3.2 队列
### 3.2.1 队列的基本概念
1. 队列的定义
队列是一种操作受限的线性表，只允许在表的一端进行插入，而在表的另一端进行删除。

2. 队列常见的基本操作
- InitQueue(& Q)：初始化队列，构造一个空队列Q。
- QueueEmpty(Q)：
- EnQueue(&Q,&x)：
- DeQueue(&Q,&x)：
- GetHead(Q,&x)：读队头元素。

### 3.2.2 队列的顺序存储结构
1. 队列的顺序存储
此处：队头指针front指向队头元素，队尾指针rear指向队尾元素的下一个位置。
    ```
    # define MaxSize 50
    typedef struct{
        ElemType data[MaxSize];
        int front,rear;
    }SeqQueue;
    ```

初始状态(队空条件)：Q.front==Q.rear==0.
由于会出现假溢出，所以不能用Q.rear==MaxSize作为队列满的条件。

2. 循环队列
循环队列把存储队列元素的表从逻辑上视为一个环。
- 初始时：Q.front = Q.rear=0
- 队首指针进1：Q.front=(Q.front+1)%MaxSize
- 队尾指针进1：Q.rear=(Q.rear+1)%MaxSize;
- 队列长度：(Q.rear+MaxSize-Q.front)%MaxSize

队空条件：Q.front==Q.rear

为了区分队空还是队满的情况，有三种处理方式：
- 1）牺牲一个单元来区分队空和队满，入队时少用一个队列单元，这是一个较为普遍的做法。约定以"队头指针在队尾指针的下一位置作为队满的标志"
\
队满条件：(Q.rear+1) % MaxSize == Q.front
队空条件：Q.front == Q.rear
队列中元素的个数：(Q.rear-Q.front+MaxSize) % MaxSize
\
- 2）类型中增设表示元素个数的数据成员。这样，队空的条件为Q.size==0;队满的条件为Q.size == MaxSize。这两种情况都有Q.front == Q.rear。
- 3）类型中增设tag数据成员，以区分队满还是队空.tag等于0，若因删除导致Q.front == Q.rear，则为队空；tag等于1时，若因插入导致Q.front==Q.rear,则为队满。

3. 循环队列的操作
- 3.1 初始化
    ```
    void InitQueue(SeqQueue &Q){
        Q.rear=Q.front=0;
    }
    ```

- 3.2 判队空
    ```
    bool isEmpty(SeqQueue Q){
        if(Q.rear==Q.front) return true;
        else return false;
    }
    ```
- 3.3 入队
    ```
    bool EnQueue(SeqQueue &Q, ElemType x){
        if((Q.rear+1)% MaxSize == Q.front) return false;
        Q.data[Q.rear]=x;
        Q.rear=(Q.rear+1)% MaxSize;
        return true;
    }
    ```
- 3.4 出队
    ```
    bool DeQueue(SeqQueue &Q,ElemType &x){
        if(Q.rear==Q.front) return false;
        x=Q.data[Q.front];
        Q.front=(Q.front+1)%MaxSize;
        return true;
    }
    ```

### 3.2.3 队列的链式存储结构
1. 队列的链式存储
链式队列实际上是一个同时带有队头指针和队尾指针的单链表。头指针指向队列结点，尾指针指向队尾结点，即单链表的最后一个结点(注意与顺序存储不同)。

不带头结点的链式存储：
    ```
    typedef struct{
        ElemType data;
        struct LinkNode * next;
    }LinkNode;

    typedef struct{
        LinkNode * front,*rear;
    }LinkQueue;
    ```
不带头结点的链式队列在操作上往往比较麻烦，因此通常将链式队列设计成一个带头结点的单链表，这样插入和删除操作就统一了。


2. 链式队列的基本操作
带头结点的单链表能统一插入和删除操作。
- 2.1 初始化
    ```
    void InitQueue(LinkQueue &Q){
        Q.front=Q.rear=(LinkNode*)malloc(sizeof(LinkNode));
        Q.front->next=NULL;
    }
    ```
- 2.2 判队空
    ```
    bool IsEmpty(LinkQueue Q){
        if(Q.front == Q.rear)return true;
        else return false;
    }
    ```
- 2.3 入队
    ```
    void EnQueue(LinkQueue &Q,ElemType x){
        LinkNode * s=(LinkNode *) malloc(sizeof(LinkNode));
        s->data=x;
        s->next=NULL;
        Q.rear->next=s;
        Q.rear=s;
    }
    ```

- 2.4 出队
    ```
    bool DeQueue(LinkQueue &Q,ElemType &x){
        if(Q.front==Q.rear) return false;
        LinkNode * p=Q.front->next;
        x=p->data;
        Q.front->next=p->next;
        if(Q.rear==p)
            Q.rear=Q.front;
        free(p);
        return true;
    }
    ```
### 3.2.4 双端队列
双端队列是指允许两端都可以进行入队和出队操作的队列。其元素的逻辑结构仍是线性结构。将队列的两端分别成为前端和后端，两端都可以入队和出队。

这里涉及到不同的出队序列的问题。


## 3.3 栈和队列的应用


