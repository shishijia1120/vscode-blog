# 5 树与二叉树

## 5.1 树的基本概念


## 5.2 二叉树的概念
1. 二叉树的定义

。。。

## 5.3 二叉树的遍历和线索二叉树
### 5.3.1 二叉树的遍历
1. **先序遍历**
    ```
    void PreOrder(BiTree T){
        if(T!=NULL){
            visit(T);
            PreOrder(T->lchild);
            PreOrder(T->rchild);
        }
    }
    ```
2. **中序遍历**
    ```
    void InOrder(BiTree T){
        if(T!=NULL){
            InOrder(T->lchild);
            visit(T);
            InOrder(T->rchild);
        }
    }
    ```

3. **后序遍历**
    ```
    void PostOrder(BiTree T){
        if(T!=NULL){
            InOrder(T->lchild);
            InOrder(T->rchild);
            visit(T);
        }
    }
    ```

4. **递归算法和非递归算法的转换**
- 4.1先序遍历的非递归算法：
    ```
    void PreOrder2(BiTree T){
        InitStack(S);
        BiTree p=T;
        while(p||!IsEmpty(S)){
            if(p){
                visit(p);
                Push(S,p);
                p=p->lchild;
            }
            else{
                Pop(S,p);  
                p=p->rchild;
            }
        }
    }
    ```

- 4.2 中序遍历的非递归算法：
    ```
    void InOrder2(BiTree T){
        InitStack(S);
        BiTree p=T;
        while(p||!IsEmpty(S)){
            if(p){
                Push(S,p);
                p=p->lchild;
            }
            else{
                Pop(S,p);
                visit(p);
                p=p->rchild;
            }
        }
    }
    ```

- 4.3 利用栈的后序遍历非递归算法

。。。

5. **层次遍历**
    ```
    void LevelOrder(BiTree T){
        InitQueue(Q);
        BiTree p;
        EnQueue(Q,T);
        while(!IsEmpty(Q)){
            DeQueue(Q,p);
            visit(p);
            if(p->lchild!=NULL)
                EnQueue(Q,p->lchild);
            if(p->rchild!=NULL)
                EnQueue(Q,p->rchild);
        }
    }
    ```

6. 由遍历序列构造二叉树
。。。




### 5.3.2 线索二叉树
1. 线索二叉树的基本概念
遍历二叉树是以一定的规则将二叉树中的结点排列成一个线性序列，从而得到几种遍历序列，使得该序列中的每个结点(第一个和最后一个结点除外)都有一个直接前驱和直接后继。

在含n个结点的二叉树中，有n+1个空指针。由此设想是否能利用这些空指针来存放指向其前驱或后继的增长？这样就可以像遍历单链表那样方便地遍历二叉树。引入线索二叉树正是为了加快查找结点前驱和后继的速度。

    ```
    typedef struct ThreadNode{
        ElemType data;
        struct ThreadNode * lchild,*rchild;
        int ltag,rtag;
    }ThreadNode,*ThreadTree;
    ```
指向结点前驱和后继的指针成为线索。加上线索的二叉树成为线索二叉树。

2. 中序线索二叉树的构造
    ```
    void InThread(ThreadTree & p,ThreadTree & pre){
        if(p!=NULL){
            InThread(p->lchild,pre);
            if(p->lchild==NULL){
                p->lchild=pre;
                p->ltag=1;
            }
            if(pre!=NULL && pre->rchild == NULL){
                pre->rchild=p;
                pre->rtag=1;
            }
            pre=p;
            InThread(p->rchild,pre);
        }
    }

    void CreateInThread(ThreadTree T){
        if(T!=NULL){
            InThread(T,pre);
            pre->rchild=NULL;
            pre->rtag=1;
        }
    }
    ```


3. 中序线索二叉树的遍历
- 3.1 求中序线索二叉树中中序序列下的第一个结点： 
    ```
    ThreadNode * Firstnode(ThreadNode * p){
        while(p->ltag == 0) p=p->lchild;
        return p;
    }
    ```
- 3.2 求中序线索二叉树中结点p中中序序列下的后继：
    ```
    ThreadNode *Nextnode(ThreadNode *p){
        if(p->rtag==0)return Firstnode(p->rchild);
        else return p->rchild;
    }
    ```
- 3.3 利用上面两个算法，写出中序线索二叉树的中序遍历的算法：
    ```
    void Inorder(ThreadNode * T){
        for(ThreadNode *p=Firstnode(T); p!=NULL; p=Nextnode(p))
            visit(p);
    }
    ```


4. 先序二叉树和后序线索二叉树
。。。


## 5.4 树、森林
### 5.4.1 树的存储结构
1. 双亲表示法
2. 孩子表示法
3. 孩子兄弟表示法


### 5.4.2 树、森林与二叉树的转换
。。。


### 5.4.3 树和森林的遍历

。。。



### 5.4.4 树的应用——并查集
。。。

## 5.5 树与二叉树的应用
### 5.5.1 二叉排序树(BST)
1. 二叉排序树的定义
2. 二叉排序树的查找
3. 二叉排序树的插入
4. 二叉排序树的构造
5. 二叉排序树的删除
6. 二叉排序树的查找效率分析


### 5.5.2 平衡二叉树
1. 平衡二叉树的定义
2. 平衡二叉树的插入
3. 平衡二叉树的查找


### 5.5.3 哈夫曼树和哈夫曼编码
1. 哈夫曼树的定义
2. 哈夫曼树的构造
3. 哈夫曼编码



